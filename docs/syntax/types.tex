\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[]{mathpartir}
\usepackage[]{plong}
\usepackage{amsmath, amsthm, amssymb}

\begin{document}
\section{Type synthesis for terms}
The type synthesis judgment for terms is written
\fbox{$\judge \aContext \aTerm \aType$}
and reads "We infer the type $\aType$ for the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule  {\judgequal \aContext \aVar \aType} 
        {\judge \aContext \aVar \aType}
        {Variable}

\aRule  {\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType}
        {\judge \aContext {\tfun \aVar {\aType[1]} \aTerm} \domToCod}
        {Abstraction}

\aRule   {\judge \aContext \aTerm \domToCod \\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {Function application}

\aRule   {\judge \aContext \aTerm \aType \\
          \judge {\ctxtExtend \aContext \aVar \aType} {\aTerm[1]} {\aType[1]}}
         {\judge \aContext {\tlet \aVar \aTerm {\aTerm[1]}} {\aType[1]}}
         {Let binding}

\aRule   {\judge {\aContext \ctxtSep \aTypeVar} \aTerm \aType \\
          \aTypeVar \notin freetyvars(\aContext)}
         {\judge \aContext {\ttyfun \aTypeVar \aTerm} {\tforall \aTypeVar \aType}}
         {Type abstraction}

\aRule  {\judge \aContext \aTerm {\tforall \aTypeVar \aType}}
        {\judge \aContext {\ttyapp \aTerm {\aType[1]}} {\ttyapp \aType {\aTypeVar \mapsto {\aType[1]}}}}
        {Type application}

\aRule  {\judgecheck \aContext \aType \aTerm}
        {\judge \aContext {\ttyann \aTerm \aType} \aType}
        {Type annotation}
\end{mathpar}

\section{Type checking for terms}
The type checking judgment for terms is written
\fbox{$\judgecheck \aContext \aType \aTerm$}
and reads "We verify the type $\aType$ of the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm {\aType[1]} \\
          \judgequiv \aContext {\aType[1]} \aType}
         {\judgecheck \aContext \aType \aTerm}
         {Type checking}

\end{mathpar}

\section{Type synthesis for frames}
The type synthesis judgment for frames is written
\fbox{$\frameJudge \aContext \aFrame \aTerm \aType$}
and reads "We infer the type $\aType$ for the evaluation of the term $\aTerm$ in the frame $\aFrame$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {\frameJudge \aContext \aFunFrame \aTerm \aType}
         {Applied function}

\aRule   {\judge \aContext {\ttyapp \aTerm {\aType[1]}} \aType}
         {\frameJudge \aContext \aPolyFrame \aTerm \aType}
         {Instantiated polymorphism}
\end{mathpar}

\section{Type synthesis for stacks}
The type synthesis judgment for stacks is written
\fbox{$\frameJudge \aContext \aStack \aTerm \aType$}
and reads "We infer the type $\aType$ for the evaluation of the term $\aTerm$ in the stack $\aStack$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm \aType}
         {\frameJudge \aContext \emptyStack \aTerm \aType}
         {Empty stack}

\aRule   {\frameJudge \aContext \aStack \aTerm \domToCod\\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\frameJudge \aContext {\nonEmptyStack \aFunFrame \aStack} \aTerm \aType}
         {Applied function stack}

\aRule   {\frameJudge \aContext \aStack \aTerm {\tforall \aTypeVar \aType}}
         {\frameJudge \aContext {\nonEmptyStack \aPolyFrame \aStack} \aTerm {\ttyapp \aType {\aTypeVar \mapsto {\aType[1]}}}}
         {Instantiated polymorphism stack}
\end{mathpar}
\end{document}
