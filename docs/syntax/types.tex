\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[]{mathpartir}
\usepackage[]{plong}
\usepackage{amsmath, amsthm, amssymb}

\begin{document}
\section{Type synthesis for terms}
The type synthesis judgment for terms is written
\fbox{$\judge \aContext \aTerm \aType$}
and reads "We infer the type $\aType$ for the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule  {\judgequal \aContext \aVar \aType} 
        {\judge \aContext \aVar \aType}
        {Variable}

\aRule { }
       {\judge \aContext \true \tyBool}
       {True}

\aRule { }
       {\judge \aContext \false \tyBool}
       {False}

\aRule  {\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType}
        {\judge \aContext {\tfun \aVar {\aType[1]} \aTerm} \domToCod}
        {Abstraction}

\aRule   {\judge \aContext \aTerm \domToCod \\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {Function application}

\aRule   {\judge \aContext \aTerm \aType \\
          \judge {\ctxtExtend \aContext \aVar \aType} {\aTerm[1]} {\aType[1]}}
         {\judge \aContext {\tlet \aVar \aTerm {\aTerm[1]}} {\aType[1]}}
         {Let binding}

\aRule   {\judge \aContext \aTerm \tyBool \\
          \judge \aContext {\aTerm[2]} \aType \\
          \judgecheck \aContext \aType {\aTerm[3]}}
         {\judge \aContext {\ite \aTerm {\aTerm[2]} {\aTerm[3]}} \aType}
         {If then else}

\aRule   {\judge {\aContext \ctxtSep \aTypeVar} \aTerm \aType \\
          \aTypeVar \notin freetyvars(\aContext)}
         {\judge \aContext {\ttyfun \aTypeVar \aTerm} {\tforall \aTypeVar \aType}}
         {Type abstraction}

\aRule  {\judge \aContext \aTerm {\tforall \aTypeVar \aType}}
        {\judge \aContext {\ttyapp \aTerm {\aType[1]}} {\ttyapp \aType {\ttysub \aTypeVar \aType[1]}}}
        {Type application}

\aRule  {\judgecheck \aContext \aType \aTerm}
        {\judge \aContext {\ttyann \aTerm \aType} \aType}
        {Type annotation}
\end{mathpar}

\section{Type checking for terms}
The type checking judgment for terms is written
\fbox{$\judgecheck \aContext \aType \aTerm$}
and reads "We verify the type $\aType$ of the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm {\aType[1]} \\
          \judgequiv \aContext {\aType[1]} \aType}
         {\judgecheck \aContext \aType \aTerm}
         {Type checking}

\end{mathpar}

\section{Type synthesis for stacks}
The type synthesis judgment for stacks is written
\fbox{$\frameJudge \aContext \aStack {\aType[1]} \aType$}
and reads "In the context $\aContext$, the stack $\aStack$ plugged with a term of type $\aType[1]$ has type $\aType$".
\begin{mathpar}
\aRule   { }
         {\frameJudge \aContext \emptyStack \aType \aType}
         {Empty stack}

\aRule   {\frameJudge \aContext \aStack \aType \aType[2] \\
          \judgecheck \aContext {\aType[1]} \subs {\aTerm[1]} \env}
         {\frameJudge \aContext {(\nonEmptyStack \aFunFrame \aStack)} \domToCod \aType[2]}
         {Applied function stack}

\aRule   {\frameJudge \aContext \aStack {\ttyapp \aType {\ttysub \aTypeVar {\subs {\aType[1]} \env}}} \aType[2]}
         {\frameJudge \aContext {(\nonEmptyStack \aPolyFrame \aStack)} {\tforall \aTypeVar \aType} \aType[2]}
         {Instantiated polymorphism stack}

\aRule  {\judge \aContext {\aTerm} {\subs {\aType[2]} \env} \\
          \judgecheck \aContext {\aType[2]} {\subs {\aTerm[1]} \env} \\
          \frameJudge \aContext \aStack {\aType[2]} \aType}
        {\frameJudge \aContext {(\nonEmptyStack \aIteFrame \aStack)} \tyBool \aType}
        {IfThenElse frame}

\end{mathpar}
\end{document}
