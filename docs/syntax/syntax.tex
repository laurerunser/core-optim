\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{pf}
\usepackage{plong}
\usepackage{listings-ocaml}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\newcommand{\TODO}[1]{\textcolor{red}{$\langle$ Pierre:}~#1\textcolor{red}{~$\rangle$}}

\begin{document}
\section{Syntax}
\subsection{Terms}
$
\begin{array}{ccll}
\aTerm, \aTerm[1], \aTerm[2] & ::= & & \\
& | & \aBase & \text{(base)} \\
& | & \tfun \aVar \aType \aTerm & \text{(abstraction)} \\
& | & \tapp \aTerm \aBase & \text{(function application)} \\
& | & \tlet \aVar \aTerm {\aTerm[1]} & \text{(let binding)} \\
& | & \ite \aTerm {\aTerm[1]} {\aTerm[2]} & \text{(conditionnal)}\\
& | & \ttyfun \aTypeVar \aTerm & \text{(type abstraction)} \\
& | & \ttyapp \aTerm \aType & \text{(type application)} \\
& | & \ttyann \aTerm \aType & \text{(type annotation)}
\end{array}
$\\
$
\begin{array}{ccll}
\aBase & ::= & & \\
& | & \aVar & \text{(variable)} \\
& | & \true & \text{(true)} \\
& | & \false & \text{(false)} \\
\end{array}
$
\subsection{Types}
$
\begin{array}{ccll}
\aType, \aType[1] & ::= & & \\
& | & \aTypeVar & \text{(type variable)} \\
& | & \tyBool & \text{(bool type)} \\
& | & \aDomType \to \aCodType & \text{(function type)} \\
& | & \tforall \aTypeVar \aType & \text{(polymorphic type)} \\
& | & \aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k} & \text{(tuples)}
\end{array}
$
\section{Free variables} \label{free-variable}
\subsection{Free type variables in type}
\begin{align*}
FV(\aTypeVar) &= \aTypeVar \\
FV(\tyBool) &= \emptyset \\
FV(\domToCod) &= FV(\aDomType) \cup FV(\aCodType) \\
FV(\tforall \aTypeVar \aType) &= FV(\aType) \setminus \{ \aTypeVar \} \\
FV(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k}) &= FV(\aType[2]) \cup FV(\aType[3]) \cup \ldots \cup FV(\aType_{k}) \\
\end{align*}
\subsection{Free variables in term}
\begin{align*}
FV(\aVar) &= \aVar \\
FV(\true) &= \emptyset \\
FV(\false) &= \emptyset \\
FV(\tfun \aVar \aType \aTerm) &= FV(\aType) \cup (FV(\aTerm) \setminus \{ \aVar \}) \\
FV(\tapp \aTerm \aBase) &= FV(\aTerm) \cup FV(\aBase) \\
FV(\tlet \aVar \aTerm {\aTerm[1]}) &= FV(\aTerm) \cup (FV(\aTerm[1]) \setminus \{\aVar\}) \\
FV(\ite \aTerm {\aTerm[1]} {\aTerm[2]}) &= FV(\aTerm) \cup FV(\aTerm[1]) \cup FV(\aTerm[2]) \\
FV(\ttyfun \aTypeVar \aTerm) &= FV(\aTerm) \setminus \{ \aTypeVar \} \\
FV(\ttyapp \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
FV(\ttyann \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
\end{align*}
\section{Scoped terms}
\subsection{Terms environnement}
$
\begin{array}{ccll}
\env & ::= & \\
& | & \envid & \text{(identity)}\\
& | & \envextend \rho \aVar \aBase & \text{(variable)} \\
& | & \envextend \rho \aTypeVar \aType & \text{(type variable)}
\end{array}
$\\
We will write $\scoped \aTerm \env$ to denote the pair of the term $\aTerm$ and its environment $\env$.  \\
Similarly, $\scoped \aType \env$ denotes the pair of the type $\aType$ and its environment $\env$. \\

\subsection{Substitution} \label{substitution}
\subsubsection{Type substitution}
\begin{align*}
\subs \aTypeVar \envid &= \aTypeVar \\
\subs \aTypeVar {\envextend \env \aVar \aBase} &= \subs \aTypeVar \rho \\
\subs \aTypeVar {\envextend \env {\aTypeVar[1]} \aType} &=
\begin{cases}
  \aType & \text{if } \aTypeVar = \aTypeVar[1] \\
  \subs \aTypeVar \env & \text{otherwise} \\
\end{cases} \\
\subs \tyBool \env &= \tyBool \\
\subs {(\aDomType \to \aCodType)} \env &= \subs \aDomType \env \to \subs \aCodType \env \\
\subs {(\tforall \aTypeVar \aType)} \env &= \tforall {\aTypeVar[1]} {\subs \aType {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\tforall \aTypeVar \aType) \cup FV(\env) \\
\subs {(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k})} \env &= \subs {\aType[2]} \env \tprod \subs {\aType[3]} \env \tprod \ldots \subs {\tprod \aType_{k}} \env
\end{align*}
\subsubsection{Term substitution}
\begin{align*}
\subs \aVar \envid &= \aVar \\
\subs \aVar {\envextend \env {\aVar[1]} \aBase} &=
\begin{cases}
  \aBase & \text{if } \aVar = \aVar[1] \\
  \subs \aVar \env & \text{otherwise}
\end{cases} \\
\subs \aVar {\envextend \env \aTypeVar \aType} &= \subs \aVar \env \\
\subs \true \env &= \true \\
\subs \false \env &= \false \\
\subs {(\tfun \aVar \aType \aTerm)} \env &= \tfun {\aVar[1]} {\subs \aType \env} {\subs \aTerm {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tfun \aVar \aType \aTerm) \cup FV(\env) \\
\subs {(\tapp \aTerm {\aTerm[1]})} \env &= \tapp {\subs \aTerm \env} {\subs {\aTerm[1]} \env} \\
\subs {(\tlet \aVar \aTerm \aTerm[1])} \env &= \tlet {\aVar[1]} {\subs \aTerm \env} {\subs {\aTerm[1]} {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tlet \aVar \aTerm \aTerm[1]) \cup FV(\env) \\
\subs {(\ite \aTerm {\aTerm[1]} {\aTerm[2]})} \env &= \ite {\subs \aTerm \env} {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env} \\
\subs {(\ttyfun \aTypeVar \aTerm)} \env &= \ttyfun {\aTypeVar[1]} {\subs \aTerm {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm) \cup FV(\env) \\
\subs {(\ttyapp \aTerm \aType)} \env &= \ttyapp {\subs \aTerm \env} {\subs \aType \env} \\
\subs {\ttyann \aTerm \aType} \env &= \ttyann {\subs \aTerm \env} {\subs \aType \env}
\end{align*}

\subsection{Domaine}
The domaine of an environment is written $D(\env)$ and is equal to $\{ \aVar ~\vert~ \exists \aBase. \aVar \ne \aBase \text{ and } \subs \aVar \env = \aBase \} \cup \{ \aTypeVar ~\vert~ \exists \aType. \aTypeVar \ne \aType \text{ and } \subs \aTypeVar \env = \aType \}$

\subsection{Well scoped} \label{well-scoped-term}
$\scoped \aTerm \env$ is well-scoped if $FV(\aTerm) \subseteq D(\env)$ \\
$\scoped \aType \env$ is well-scoped if $FV(\aType) \subseteq D(\env)$

\section{Frames and stacks}
$
\begin{array}{ccll}
\aFrame & ::= & \\
& | & \aFunFrame & \text{(applied function)} \\
& | & \aPolyFrame & \text{(instantiated polymorphism)} \\
& | & \aIteFrame & \text{(if then else)}
\end{array}
$
\newline
\newline
$
\aStack ::= \emptyStack \:|\: \nonEmptyStack \aFrame \aStack \quad \text{(stacks)}
$
\subsection{Stack application} \label{stack-application}
\begin{align*}
  \stackapp \emptyStack \aTerm &= \aTerm \\
  \stackapp {(\nonEmptyStack \aFunFrame \aStack)} \aTerm &= \stackapp \aStack {\tapp \aTerm {(\subs \aBase \env)}} \\
  \stackapp {(\nonEmptyStack \aPolyFrame \aStack)} \aTerm &= \stackapp \aStack {\ttyapp \aTerm {\subs {\aType[1]} \env}} \\
  \stackapp {(\nonEmptyStack \aIteFrame \aStack)} \aTerm &= \stackapp \aStack {\ite \aTerm {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env}} \\
\end{align*}

\section{Typechecker}
\subsection{Type synthesis for terms} \label{term-typechecker}
The type synthesis judgment for terms is written
\fbox{$\judge \aContext \aTerm \aType$}
and reads "We infer the type $\aType$ for the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule  {\judgequal \aContext \aVar \aType}
        {\judge \aContext \aVar \aType}
        {Variable}

\aRule { }
       {\judge \aContext \true \tyBool}
       {True}

\aRule { }
       {\judge \aContext \false \tyBool}
       {False}

\aRule  {\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType}
        {\judge \aContext {\tfun \aVar {\aType[1]} \aTerm} \domToCod}
        {Abstraction}

\aRule   {\judge \aContext \aTerm \domToCod \\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {Function application}

\aRule   {\judge \aContext \aTerm \aType \\
          \judge {\ctxtExtend \aContext \aVar \aType} {\aTerm[1]} {\aType[1]}}
         {\judge \aContext {\tlet \aVar \aTerm {\aTerm[1]}} {\aType[1]}}
         {Let binding}

\aRule   {\judge \aContext \aTerm \tyBool \\
          \judge \aContext {\aTerm[2]} \aType \\
          \judge \aContext {\aTerm[3]} \aType}
         {\judge \aContext {\ite \aTerm {\aTerm[2]} {\aTerm[3]}} \aType}
         {If then else}

\aRule   {\judge {\aContext \ctxtSep \aTypeVar} \aTerm \aType \\
          \aTypeVar \notin FV(\aContext)}
         {\judge \aContext {\ttyfun \aTypeVar \aTerm} {\tforall \aTypeVar \aType}}
         {Type abstraction}

\aRule  {\judge \aContext \aTerm {\tforall \aTypeVar \aType}}
        {\judge \aContext {\ttyapp \aTerm {\aType[1]}} {\subs \aType {\envextend \envid \aTypeVar {\aType[1]}}}}
        {Type application}

\aRule  {\judgecheck \aContext \aType \aTerm}
        {\judge \aContext {\ttyann \aTerm \aType} \aType}
        {Type annotation}
\end{mathpar}

\subsection{Type checking for terms}
The type checking judgment for terms is written
\fbox{$\judgecheck \aContext \aType \aTerm$}
and reads "We verify the type $\aType$ of the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm {\aType[1]} \\
          \judgequiv \aContext {\aType[1]} \aType}
         {\judgecheck \aContext \aType \aTerm}
         {Type checking}

\end{mathpar}

\subsection{Lemma} \label{lemma-substitution}
\begin{proof}
  \assume{\begin{enumerate}
    \item $\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType$ \label{pf:term-type}
    \item $\judge \aContext \aBase {\aType[1]}$ \label{pf:subs-type}
  \end{enumerate}}
  \prove{$\judge \aContext {\subs \aTerm {\envextend \envid \aVar \aBase}} \aType$}
  \pfsketch\ Proof by induction on $\aTerm$
  \step{label-1}{\case{$\aTerm = \aBase'$}}
  \begin{proof}
    \step{label-1.1}{\case{$\aBase' = \aVar$}}
    \begin{proof}
      \step{label-1.1.1}{$\subs \aTerm {\envextend \envid \aVar \aBase} = \aBase$}
      \qedstep
      \begin{proof}
        \pf\ By \ref{pf:term-type} and \ref{pf:subs-type}
      \end{proof}
    \end{proof}
    \step{label-1.2}{\case{$\aBase' = \true$}}
    \begin{proof}
      \pf\ By typechecker, $\forall \aContext', \judge {\aContext'} \true \tyBool$
    \end{proof}
    \step{label-1.3}{\case{$\aBase' = \false$}}
    \begin{proof}
      \pf\ By typechecker, $\forall \aContext', \judge {\aContext'} \false \tyBool$
    \end{proof}
    \step{label-1.4}{\case{otherwise, $\aBase' = \aVar[1]$}}
    \begin{proof}
      \step{label-1.4.1}{$\subs \aTerm {\envextend \envid \aVar \aBase} = \aVar[1]$}
      \qedstep
      \begin{proof}
        \pf\ By \ref{pf:term-type}
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-2}{\case{$\aTerm = \tfun \aVar \aType {\aTerm[1]}$}}
  \begin{proof}
    \step{label-2.1}{$\subs \aTerm {\envextend \envid \aVar \aBase} = (\tfun {\aVar[1]} \aType {\subs {\aTerm[1]} {\envextend \envid \aVar {\aVar[1]}}})$}
  \end{proof}
\end{proof}

\subsection{Type synthesis for stacks} \label{stack-typechecker}
The type synthesis judgment for stacks is written
\fbox{$\frameJudge \aContext \aStack {\aType[1]} \aType$}
and reads "In the context $\aContext$, the stack $\aStack$ plugged with a term of type $\aType[1]$ has type $\aType$".
\begin{mathpar}
\aRule   { }
         {\frameJudge \aContext \emptyStack \aType {\aType}}
         {Empty stack}

\aRule   {\frameJudge \aContext \aStack \aType {\aType[2]} \\
          \judgecheck \aContext {\aType[1]} {\subs \aBase \env}}
         {\frameJudge \aContext {(\nonEmptyStack \aFunFrame \aStack)} \domToCod {\aType[2]}}
         {Applied function frame}

\aRule   {\frameJudge \aContext \aStack {\subs \aType {\envextend \envid \aTypeVar {\subs {\aType[1]} \env}}} {\aType[2]}}
         {\frameJudge \aContext {(\nonEmptyStack \aPolyFrame \aStack)} {\tforall \aTypeVar \aType} {\aType[2]}}
         {Instantiated polymorphism frame}

\aRule  {\judge \aContext {\subs {\aTerm[1]} \env} {\aType[2]} \\
          \judge \aContext {\subs {\aTerm[2]} \env} {\aType[2]} \\
          \frameJudge \aContext \aStack {\aType[2]} {\aType}}
        {\frameJudge \aContext {(\nonEmptyStack \aIteFrame \aStack)} \tyBool \aType}
        {IfThenElse frame}

\end{mathpar}

\section{Simplifications}
\subsection{Constant folding} \label{constant-folding}
\subsubsection{Rules}
\begin{mathpar}
\aRule   { }
         {\simplBeta {\tapp {(\tfun \aVar \aType \aTerm)} \aBase} {{\subs \aTerm {\envextend \envid \aVar \textcolor{orange}{\frak{\aBase}}}}}}
         {}

\aRule   { }
         {\simplBeta {\ttyapp {(\ttyfun \aTypeVar \aTerm)} \aType} {{\subs \aTerm {\envextend \envid \aTypeVar \textcolor{orange}{\frak{\aType}}}}}}
         {}

\aRule   { }
         {\simplBeta {{\ite \true \aTerm {\aTerm[1]}}} {\aTerm}}
         {}

\aRule   { }
         {\simplBeta {{\ite \false \aTerm {\aTerm[1]}}} {\aTerm[1]}}
         {}
\end{mathpar}
\subsubsection{Congruence rules}
\begin{mathpar}
\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aVar {\textcolor{orange}{\frak{\aVar}}}}} {\aTerm[1]}}
         {\simplBeta {\tfun \aVar \aType \aTerm} {\tfun {\textcolor{orange}{\frak{\aVar}}} \aType {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\tapp \aTerm \aBase} \tapp {\aTerm[1]} \aBase}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'}}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet \aVar {\aTerm'}} {\aTerm[1]}}
         {}

\aRule   {\simplBeta {\subs {\aTerm[1]} {\envextend \envid \aVar {\textcolor{orange}{\frak{\aVar}}}}} {\aTerm[1]'}}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet {\textcolor{orange}{\frak{\aVar}}} \aTerm \aTerm[1]'}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm'} {\aTerm[1]} {\aTerm[2]}}}
         {}

\aRule   {\simplBeta {\aTerm[1]} {\aTerm[1]'}}
          {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]'} {\aTerm[2]} }}
{}

\aRule   {\simplBeta {\aTerm[2]} {\aTerm[2]'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]} {\aTerm[2]'}}}
         {}

\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aTypeVar {\textcolor{orange}{\frak{\aTypeVar}}}}} {\aTerm[1]}}
         {\simplBeta {\ttyfun \aTypeVar \aTerm} {\ttyfun {\textcolor{orange}{\frak{\aTypeVar}}} {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\ttyapp \aTerm \aType} {\ttyapp {\aTerm[1]} \aType}}
         {}

\aRule   { }
         {\simplBeta {\ttyann \aTerm \aType} \aTerm}
         {}

\end{mathpar}

\subsubsection{Lemma} \label{lemma-simpl-stable-context}
\begin{proof}
  \pflet{\begin{enumerate}
    \item $\aStack$ be a stack
    \item $\aTerm, \aTerm'$ be terms
  \end{enumerate}}
  \assume{$\simplBeta \aTerm {\aTerm'}$}
  \prove{$\simplBeta {\stackapp \aStack \aTerm} {\stackapp \aStack {\aTerm'}}$}
  \pfsketch\ Proof by induction on $\aStack$
  \step{label-1}{\case{$\aStack = \emptyStack$}}
  \begin{proof}
    \pf\ By definition of $\stackapp {\_} {\_}$
  \end{proof}
  \step{label-2}{\case{$\aStack = \nonEmptyStack \aFunFrame {\aStack'}$}}
  \begin{proof}
    \step{label-2.1}{$\stackapp \aStack \aTerm = \stackapp {\aStack'} {\tapp \aTerm {(\subs \aBase \env)}}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$  
    \end{proof}
    \step{label-2.2}{$\stackapp \aStack {\aTerm'} = \stackapp {\aStack'} {\tapp {\aTerm'} {(\subs \aBase \env)}}$}
    \step{label-2.3}{$\simplBeta {\tapp \aTerm {(\subs \aBase \env)}} {\tapp {\aTerm'} {(\subs \aBase \env)}}$}
    \begin{proof}
      \pf\ By definition of $\rightsquigarrow$ 
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ By IH on $\aStack' < \aStack$
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aStack = \nonEmptyStack \aPolyFrame {\aStack'}$}}
  \step{label-4}{\case{$\aStack = \nonEmptyStack \aIteFrame {\aStack'}$}}
\end{proof}

\subsection{{\sf go} definition}
\begin{align*}
\go {\scoped \aBase \env} \aStack &= 
\begin{cases}
  \go {\scoped {\aTerm[1]} {\env'}} {\aStack'} & \text{if } \subs \aBase \env = \true \text{ and } \aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'} \\
  \go {\scoped {\aTerm[2]} {\env'}} {\aStack'} & \text{if } \subs \aBase \env = \false \text{ and } \aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'} \\
  \plug \aStack {(\subs {\aBase} \env)} & \text{otherwise}
\end{cases} \\
\go {\scoped {(\tfun \aVar \aType \aTerm)} \env} {\aStack} &=
\begin{cases}
  \go {\scoped \aTerm {\envextend \env \aVar {\subs \aBase {\env'}}}} {\aStack'} & \text{if } \aStack = \nonEmptyStack {\aFunFrame[\env']} {\aStack'} \\
  \begin{aligned}
    &\plug \aStack {(\tfun {\aVar[1]} {\subs \aType \env} {(\go {\scoped \aTerm {\envextend \env \aVar {\aVar[1]}}} \emptyStack)})} \\
    &\text{with $\aVar[1] \notin FV(\subs \aTerm \env)$}
  \end{aligned} & \text{otherwise} 
\end{cases} \\
\go {\scoped {(\ttyfun \aTypeVar \aTerm)} \env} {\aStack} &=
\begin{cases}
  \go {\scoped \aTerm {\envextend \env \aTypeVar {\subs {\aType[1]} {\env'}}}} {\aStack'} & \text{if } \aStack = \nonEmptyStack {\aPolyFrame[\env']} {\aStack'} \\
  \begin{aligned}
    &\plug \aStack {(\ttyfun {\aTypeVar[1]} {(\go {\scoped \aTerm {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack)})} \\
    &\text{with $\aTypeVar[1] \notin FV(\subs \aTerm \env)$}
  \end{aligned} & \text{otherwise} 
\end{cases} \\
\go {\scoped {(\tapp \aTerm \aBase)} \env} \aStack &= \go {\scoped \aTerm \env} {(\nonEmptyStack \aFunFrame \aStack)} \\
\go {\scoped {(\ttyapp \aTerm {\aType[1]})} \env} \aStack &= \go {\scoped \aTerm \env} {(\nonEmptyStack \aPolyFrame \aStack)} \\
\go {\scoped {(\ite \aTerm {\aTerm[1]} {\aTerm[2]})} \env} &= \go {\scoped \aTerm \env} {(\nonEmptyStack \aIteFrame \aStack)} \\
\go {\scoped {(\tlet \aVar \aTerm {\aTerm[1]})} \env} \aStack &= \plug \aStack {(\tlet {\aVar[1]} {(\go {\scoped \aTerm \env} \emptyStack)} {(\go {\scoped {\aTerm[1]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack)})} \text{ with } \aVar[1] \notin FV(\tlet \aVar \aTerm {\aTerm[1]}) \cup FV(\env) \\ 
\go {\scoped {(\ttyapp \aTerm \aType)} \env} \aStack &= \go {\scoped \aTerm \env} \aStack  
\end{align*}

\subsection{{\sf plug} definition}
\begin{align*}
\plug \emptyStack \aTerm &= \aTerm \\
\plug {(\nonEmptyStack \aFunFrame \aStack)} \aTerm &= \plug \aStack {(\tapp \aTerm {(\subs \aBase \env)})} \\
\plug {(\nonEmptyStack \aPolyFrame \aStack)} \aTerm &= \plug \aStack {(\ttyapp \aTerm {\subs {\aType[1]} \env})} \\
\plug {(\nonEmptyStack {(\aIteFrame)} \aStack)} \aTerm &= \plug \aStack {(\ite \aTerm {\go {\scoped {\aTerm[1]} \env} \emptyStack} {\go {\scoped {\aTerm[2]} \env} \emptyStack})}
\end{align*}

\subsection{Neutral term}
\begin{mathpar}
\aRule  { }
        {\aVar \text{ neutral}}
        {}

\aRule  {\aTerm \text{ neutral}}
        {\tapp \aTerm \aBase \text{ neutral}}
        {}

\aRule  {\aTerm \text{ neutral}}
        {\ttyapp \aTerm {\aType} \text{ neutral}}
        {}

\aRule  {\aTerm \text{ neutral} \\ \betaNormal {\aTerm[1]} \\ \betaNormal {\aTerm[2]}}
        {\ite \aTerm {\aTerm[1]} {\aTerm[2]} \text{ neutral}}
        {}

\end{mathpar}

\subsubsection{Lemma}\label{lemma-neutral-term}
\begin{proof}
  \assume{$\aTerm$ is a neutral term}
  \prove{$\betaNormal{\aTerm}$}
  \pfsketch\ Proof by induction on $\aTerm$
  \step{label-1}{\case{$\aTerm = \aVar$}}
  \begin{proof}
    \pf\ By definition of $\rightsquigarrow$
  \end{proof}
  \step{label-2}{\case{$\aTerm = \tapp {\aTerm'} \aBase$}}
  \begin{proof}
    \step{label-2.1}{$\betaNormal{\aTerm'}$}
    \begin{proof}
      \step{label-2.1.1}{$\aTerm'$ is neutral}
      \begin{proof}
        \pf\ By inversion of hypothesis
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $\aTerm' < \aTerm$
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ By definition of $\rightsquigarrow$
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aTerm = \ttyapp {\aTerm'} \aType$}}
  \step{label-4}{\case{$\aTerm = \ite {\aTerm[3]}{\aTerm[4]}{\aTerm[5]}$}}
\end{proof}

\subsection{Simplifiable stack}
\begin{mathpar}
\aRule  { }
        {\emptyStack \text{ simplifiable}}
        {}

\aRule  {\aStack \text{ simplifiable}}
        {\nonEmptyStack \aFunFrame \aStack \text{ simplifiable}}
        {}

\aRule  {\aStack \text{ simplifiable}}
        {\nonEmptyStack \aPolyFrame \aStack \text{ simplifiable}}
        {}

\aRule  {\aStack \text{ simplifiable} \\
          \simplBeta[*] {\stackapp \emptyStack {\subs {\aTerm[1]} \env}} {\betaNormal {\go {\scoped {\aTerm[1]} \env} {\emptyStack}}} \\
          \simplBeta[*] {\stackapp \emptyStack {\subs {\aTerm[2]} \env}} {\betaNormal {\go {\scoped {\aTerm[2]} \env} {\emptyStack}}} \\
          \simplBeta[*] {\stackapp \aStack {\subs {\aTerm[1]} \env}} {\betaNormal {\go {\scoped {\aTerm[1]} \env} {\aStack}}} \\
          \simplBeta[*] {\stackapp \aStack {\subs {\aTerm[1]} \env}} {\betaNormal {\go {\scoped {\aTerm[1]} \env} {\aStack}}}}
        {\nonEmptyStack \aIteFrame \aStack \text{ simplifiable}}
        {}
\end{mathpar}
\subsubsection{Lemma} \label{neutral-simpl}
\begin{proof}
  \assume{\begin{enumerate}
    \item $\aTerm$ is neutral term \label{pf:term-neutral}
    \item $\aStack$ is a simplifiable stack \label{pf:stack-simplifiable}
  \end{enumerate}}
  \prove{$\simplBeta[*]{\stackapp \aStack \aTerm} {\betaNormal{\plug \aStack \aTerm}}$}
  \pfsketch\ Proof by induction on $\aStack$
  \step{label-1}{\case{$\aStack = \emptyStack$}}
  \begin{proof}
    \pf\ By lemma \ref{lemma-neutral-term}
  \end{proof}
  \step{label-2}{\case{$\aStack = \nonEmptyStack {\aFunFrame} {\aStack'}$}}
  \begin{proof}
    \pflet{$\aTerm' = \tapp \aTerm {(\subs \aBase \env)}$}
    \step{label-2.1}{$\stackapp \aStack \aTerm = \stackapp {\aStack'} {\aTerm'}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-2.2}{$\simplBeta[*]{\stackapp {\aStack'} {\aTerm'}} {\betaNormal{\plug {\aStack'} {\aTerm'}}}$}
    \begin{proof}
      \step{label-2.2.1}{$\aTerm'$ neutral}
      \begin{proof}
        \pf\ By \ref{pf:term-neutral}
      \end{proof}
      \step{label-2.2.2}{$\aStack'$ simplifiable}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-simplifiable}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $\aStack' < \aStack$
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ $\begin{aligned}[t]
        \stackapp \aStack \aTerm &= \stackapp {\aStack'} {\aTerm'} && \text{\stepref{label-2.1}} \\
        &\rightsquigarrow^* \plug {\aStack'} {\aTerm'} && \text{\stepref{label-2.2}} \\
        &= \plug \aStack \aTerm && \text{definition of {\sf plug}} \\
        &\not\rightsquigarrow && \text{\stepref{label-2.2}}
      \end{aligned}$
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aStack = \nonEmptyStack {\aPolyFrame} {\aStack'}$}}
  \step{label-4}{\case{$\aStack = \nonEmptyStack {\aIteFrame} {\aStack'}$}}
  \begin{proof}
    \step{label-4.1}{$\stackapp \aStack \aTerm = \stackapp {\aStack'} {\ite \aTerm {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env}}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-4.2}{$\simplBeta[*]{\stackapp \emptyStack {\subs {\aTerm[1]} \env}} {\betaNormal{\go {\scoped {\aTerm[1]} \env} \emptyStack}}$}
    \begin{proof}
      \pf\ By inversion of \ref{pf:stack-simplifiable}
    \end{proof}
    \step{label-4.3}{$\simplBeta[*]{\stackapp \emptyStack {\subs {\aTerm[2]} \env}} {\betaNormal{\go {\scoped {\aTerm[2]} \env} \emptyStack}}$}
    \pflet{$\aTerm' = \ite {\aTerm} {\go {\scoped {\aTerm[1]} \env} \emptyStack} {\go {\scoped {\aTerm[2]} \env} \emptyStack}$}
    \step{label-4.4}{$\simplBeta[*]{\stackapp {\aStack'} {\ite \aTerm {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env}}}{\stackapp {\aStack'} {\aTerm'}}$}
    \begin{proof}
      \pf\ By \stepref{label-4.2} and \stepref{label-4.3} and lemma \ref{lemma-simpl-stable-context}
    \end{proof}
    \step{label-4.5}{$\simplBeta[*]{\stackapp {\aStack'} {\aTerm'}} {\betaNormal{\plug {\aStack'} {\aTerm'}}}$}
    \begin{proof}
      \step{label-4.5.1}{$\aTerm'$ neutral}
      \begin{proof}
        \pf\ By \ref{pf:term-neutral}, \stepref{label-4.2} and \stepref{label-4.3}
      \end{proof}
      \step{label-4.5.2}{$\aStack'$ simplifiable}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-simplifiable}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $\aStack' < \aStack$
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ $\begin{aligned}[t]
        \stackapp \aStack \aTerm &= \stackapp {\aStack'} {\ite \aTerm {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env}} && \text{\stepref{label-4.1}} \\
        &\rightsquigarrow^* \stackapp {\aStack'} {\aTerm'} && \text{\stepref{label-4.4}} \\
        &\rightsquigarrow^* \plug {\aStack'} {\aTerm'} && \text{\stepref{label-4.5}} \\
        &= \plug \aStack \aTerm && \text{definition of {\sf plug}} \\
        &\not\rightsquigarrow && \text{\stepref{label-4.5}}
      \end{aligned}$
    \end{proof}
  \end{proof}
\end{proof}

\subsection{{\sf go} correctness}
\begin{proof}
  \pflet 
  {\begin{enumerate}
    \item $\aTerm$ be a term
    \item $\env$ be a substitution
    \item $\aStack$ be a stack
  \end{enumerate}}
  \assume{$\exists \aContext, \aType ,\aType[1]$ such that
    \begin{enumerate}
      \item $\judge \aContext {\subs \aTerm \env} \aType$ \label{pf:term-typed}
      \item $\frameJudge \aContext \aStack \aType {\aType[1]}$ \label{pf:stack-typed}
      \item $\aStack$ is simplifiable \label{pf:stack-simpl}
    \end{enumerate}}
  \prove{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\go {\scoped \aTerm \env} \aStack}}$}
  \pfsketch\ Proof by induction on $\aTerm$.
  \step{label-1}{\case{$\aTerm = \aBase$ (line~\ref{go:base})}}
  \begin{proof}
    \step{label-1.1}{\case{$\begin{conj} \subs \aBase \env = \true \\ \aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'} \end{conj}$}}
    \begin{proof}
      \step{label-1.1.1}{$\go {\scoped \aTerm \env} \aStack = \go {\scoped {\aTerm[1]} {\env'} {\aStack'}}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} {\betaNormal {\go {\scoped {\aTerm[1]} {\env'} {\aStack'}}}}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-simpl}
      \end{proof}
      \step{label-1.1.3}{$\simplBeta {\stackapp \aStack {\subs \aTerm \env}} {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}}$}
      \begin{proof}
        \pf\ \\ $ \stackapp {\nonEmptyStack {\aIteFrame[\env']} {\aStack'}} {\true} \\
            \begin{aligned}[t]
            & = \stackapp {\aStack'} {\ite {\true} {\subs {\aTerm[1]} {\env'}} {\subs {\aTerm[2]} {\env'}}} && \text{definition of $\stackapp {\_} {\_}$} \\
            & \simplBeta {}  {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} && \text{lemma \ref{lemma-simpl-stable-context}}
        \end{aligned}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs \aTerm {\env}} &\rightsquigarrow {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} && \text{\stepref{label-1.1.3}}
            \\ &\rightsquigarrow^{*} {\go {\scoped {\aTerm[1]} {\env'}} {\aStack'}} && \text{\stepref{label-1.1.2}}
            \\ &= {\go {\scoped {\aTerm} {\env}} {\aStack}} && \text{\stepref{label-1.1.1}}
            \\ &\not \rightsquigarrow && \text{\stepref{label-1.1.2}}
            \end{aligned}$
      \end{proof}
    \end{proof}
    \step{label-1.2}{\case{$\begin{conj} \subs \aBase \env = \false \\ \aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'} \end{conj}$}}
    \step{label-1.3}{\case{otherwise}}
    \begin{proof}
      \step{label-1.3.1}{$\go {\scoped \aTerm \env} \aStack = \plug \aStack {(\subs \aTerm \env)}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.3.2}{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\plug \aStack {(\subs \aTerm \env)}}}$}
      \begin{proof}
        \step{label-1.3.2.1}{$\subs \aTerm \env$ is neutral}
        \begin{proof}
          \step{label-1.3.2.1.1}{$\subs \aTerm \env$ is a variable}
          \begin{proof}
            \pf\ By \ref{pf:stack-typed} and case analysis
          \end{proof}
          \qedstep
          \begin{proof}
            \pf\ By definition of neutral term
          \end{proof}
        \end{proof}
        \step{label-1.3.2.2}{$\aStack$ is simplifiable}
        \begin{proof}
          \pf\ By \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By lemma \ref{neutral-simpl}
        \end{proof}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs \aTerm {\env}} &\rightsquigarrow^* {\plug \aStack {(\subs \aTerm \env)}} && \text{\stepref{label-1.3.2}}
            \\ &= {\go {\scoped {\aTerm} {\env}} {\aStack}} && \text{\stepref{label-1.3.1}}
            \\ &\not \rightsquigarrow && \text{\stepref{label-1.3.2}}
            \end{aligned}$
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-2}{\case{$\aTerm = (\tfun \aVar {\aType[2]} {\aTerm[3]})$}}
  \begin{proof}
    \step{label-2.1}{\case{$\aStack = \nonEmptyStack {\aFunFrame[\env']} {\aStack'}$ (line~\ref{go:fun-holefun})}}
    \begin{proof}
      \pflet{$\env'' = \envextend \env \aVar {\subs \aBase {\env'}}$}
      \step{label-2.1.1}{$\go {\scoped {\aTerm} \env} \aStack = \go {\scoped {\aTerm[3]} {\env''}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\env''}} {\aStack'}}}$}
      \begin{proof}
        \step{label-2.1.2.1}{$\exists \aType[3]$ such that $\begin{conj}\aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\aContext} {\subs {\aTerm[3]} {\env''}} {\aType[3]} \\ \frameJudge {\aContext} {\aStack'} {\aType[3]} {\aType[1]} \end{conj}$}
        \begin{proof}
          \step{label-2.1.2.1.1}{$\exists \aType[3]$ such that $\begin{conj} \aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \aType[3]$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env) \end{conj}$}
          \begin{proof}
            \pf\ By substitution and inversion of \ref{pf:term-typed}
          \end{proof}
          \step{label-2.1.2.1.2}{$\begin{conj} \judge \aContext {\subs \aBase {\env'}} {\subs {\aType[2]} \env} \\ \frameJudge \aContext {\aStack'} {\aType[3]} {\aType[1]} \end{conj}$}
          \begin{proof}
            \pf\ By inversion of \ref{pf:stack-typed}
          \end{proof}
          \step{label-2.1.2.1.3}{$\judge \aContext {\subs {\aTerm[3]} {\env''}} {\aType[3]}$}
          \begin{proof}
            \step{label-2.1.2.1.3.1}{$\judge \aContext {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} {\subs \aBase {\env'}}}} {\aType[3]}$}
            \begin{proof}
              \pf\ By \stepref{label-2.1.2.1.1}, \stepref{label-2.1.2.1.2} and lemma \ref{lemma-substitution}
            \end{proof}
            \qedstep
            \begin{proof}
              \pf\ $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$
            \end{proof}
          \end{proof}
        \end{proof}
        \step{label-2.1.2.2}{$\aStack'$ is simplifiable}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH on $\aTerm[3] < \aTerm$
        \end{proof}
      \end{proof}
      \step{label-2.1.3}{$\simplBeta {\stackapp {\aStack} {\subs {\aTerm} \env}}{\stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}}}$}
      \begin{proof}
        \pf\ \\
          $\stackapp {(\nonEmptyStack {\aFunFrame[\env']} {\aStack'})} {(\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} \\
          \begin{aligned}
          & = \stackapp {\aStack'} {\tapp {(\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} {\subs \aBase {\env'}} } && \text{definition of $\stackapp \_ \_ $}\\
          & \rightsquigarrow \stackapp {\aStack'} {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} {\subs \aBase {\env'}}}} && \text{lemma \ref{lemma-simpl-stable-context}} \\
          & = \stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}} && \text{$\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
        \end{aligned}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs {\aTerm} \env}
            &\rightsquigarrow \stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}} && \text{\stepref{label-2.1.3}} \\
            &\rightsquigarrow^* \go {\scoped {\aTerm[3]} {\env''}} {\aStack'} && \text{\stepref{label-2.1.2}} \\
            &= \go {\scoped {\aTerm} \env} \aStack && \text{\stepref{label-2.1.1}} \\
            &\not \rightsquigarrow && \text{\stepref{label-2.1.2}}
          \end{aligned}$
      \end{proof}
    \end{proof}
    \step{label-2.2}{\case{otherwise (line~\ref{go:fun-else})}}
    \begin{proof}
      \pflet{$\begin{conj}
        \aVar[1] \notin FV(\aTerm) \cup FV(\env) \text{ such that } \subs \aTerm \env = (\tfun {\aVar[1]} {\subs {\aType[2]} \env}{\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}}) \\
        \aVar[2] \notin FV(\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}) \\
        \env' = \envextend \env \aVar {\aVar[2]} \\
        \aTerm' = (\tfun {\aVar[2]} {\subs {\aType[2]} \env} {\go {\scoped {\aTerm[3]} {\env'}} \emptyStack})
      \end{conj}$}
      \step{label-2.2.1}{$\go {\scoped {\aTerm} \env} \aStack = \plug \aStack {\aTerm'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.2.2}{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\plug \aStack {\aTerm'}}}$}
      \begin{proof}
        \step{label-2.2.2.1}{$\aStack$ is empty}
        \begin{proof}
          \pf\ By \ref{pf:stack-typed} and case analysis
        \end{proof}
        \step{label-2.2.2.2}{$\simplBeta[*]{\subs \aTerm \env} {\betaNormal{\aTerm'}}$}
        \begin{proof}
          \step{label-2.2.2.1.1}{$\simplBeta[*] {\stackapp {\emptyStack} {\subs {\aTerm[3]} {\env'}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\env'}} {\emptyStack}}}$}
          \begin{proof}
            \step{label-2.2.2.1.1.1}{$\exists \aContext', \aType[3]$ such that $\begin{conj}\aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\aContext'} {\subs {\aTerm[3]} {\env'}} {\aType[3]} \\ \frameJudge {\aContext'} {\emptyStack} {\aType[3]} {\aType[3]} \end{conj}$}
            \begin{proof}
              \step{label-2.2.2.1.1.1.1}{$\exists \aType[3]$ such that $\begin{conj} \aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\subs {\aTerm[3]} {\env'}} {\aType[3]} \end{conj}$}
              \begin{proof}
                \pf\ By substitution and inversion of \ref{pf:term-typed}
              \end{proof}
              \step{label-2.2.2.1.1.1.2}{$\frameJudge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\emptyStack} {\aType[3]} {\aType[3]}$}
              \begin{proof}
                \pf\ By definition
              \end{proof}
            \end{proof}
            \step{label-2.2.2.1.1.2}{$\emptyStack$ is simplifiable}
            \begin{proof}
              \pf\ By definition of simplifiable
            \end{proof}
            \qedstep
            \begin{proof}
              \pf\ By IH on $\aTerm[3] < \aTerm$
            \end{proof}
          \end{proof}
          \qedstep
          \begin{proof}
            \pf\ By definition of $\rightsquigarrow^*$
          \end{proof}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By definition of $\stackapp {\_} {\_}$ and {\sf plug}
        \end{proof}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs {\aTerm} \env}
            &\rightsquigarrow^* {\plug \aStack {\aTerm'}} && \text{by \stepref{label-2.2.2}} \\
            &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-2.2.1}} \\
            &\not \rightsquigarrow && \text{by \stepref{label-2.2.2}}
          \end{aligned}$
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aTerm = \ttyfun \aTypeVar {\aTerm[3]}$}}
  \step{label-4}{\case{$\aTerm = \tapp {\aTerm[3]} {\aBase}$ (line~\ref{go:funApply})}}
  \begin{proof}
    \pflet{$\aStack' = \nonEmptyStack {\aFunFrame[\env]} \aStack$}
    \step{label-4.1}{$\go {\scoped {\aTerm} \env} \aStack = \go {\scoped {\aTerm[3]} \env {\aStack'}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-4.2}{$\stackapp \aStack {\subs {\aTerm} \env} = \stackapp {\aStack'} {\subs {\aTerm[3]} \env}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-4.3}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} \env}} \betaNormal{{\go {\scoped {\aTerm[3]} \env} {\aStack'}}}$}
    \begin{proof}
      \step{label-4.3.1}{$\exists \aType[2]$ such that $\judge \aContext {\subs {\aTerm[3]} \env} {\aType[2] \to \aType}$}
      \begin{proof}
        \pf\ By substitution and inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-4.3.2}{$\frameJudge \aContext {\aStack'} {\aType[2] \to \aType} {\aType[1]}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-typed}
      \end{proof}
      \step{label-4.3.3}{$\aStack'$ is fully simplifiable}
      \begin{proof}
        \pf\ By \ref{pf:stack-simpl}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $\aTerm[3] < \aTerm$ 
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ $\begin{aligned}[t]
          \stackapp \aStack {\subs {\aTerm} \env}
          &= \stackapp {\aStack'} {\subs {\aTerm[3]} \env} && \text{by \stepref{label-4.2}} \\
          &\rightsquigarrow^* \go {\scoped {\aTerm[3]} \env} {\aStack'} && \text{by \stepref{label-4.3}} \\
          &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-4.1}} \\
          &\not \rightsquigarrow && \text{by \stepref{label-4.3}}
        \end{aligned}$
    \end{proof}
  \end{proof}
  \step{label-5}{\case{$\aTerm = \ttyapp {\aTerm[3]} {\aType[2]}$ (line~\ref{go:typeApply})}}
  \step{label-6}{\case{$\aTerm = \ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]}$ (line~\ref{go:ite})}}
  \begin{proof}
    \pflet{$\aStack' = \nonEmptyStack {\aIteFrameAll {\aTerm[4]} {\aTerm[5]} \env} \aStack$}
    \step{label-6.1}{$\go {\scoped {\aTerm} \env} \aStack = \go {\scoped {\aTerm[3]} \env {\aStack'}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-6.2}{$\simplBeta[*]{\stackapp \emptyStack {\subs {\aTerm[4]} \env}} {\betaNormal{\go {\scoped {\aTerm[4]} \env} \emptyStack}}$}
     \begin{proof}
      \step{label-1.1.2.1}{$\begin{conj}\judge \aContext {\subs {\aTerm[4]} {\env}} {\aType} \\ \frameJudge \aContext {\emptyStack} {\aType} {\aType} \end{conj}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-typed}
      \end{proof}
      \step{label-1.1.2.2}{$\emptyStack$ is simplifiable}
      \begin{proof}
        \pf\ By definition of simplifiable
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $\aTerm[4] <  \aTerm$
      \end{proof}
    \end{proof}
    \step{label-6.3}{$\simplBeta[*]{\stackapp \emptyStack {\subs {\aTerm[5]} \env}} {\betaNormal{\go {\scoped {\aTerm[5]} \env} \emptyStack}}$}
     \step{label-6.4}{${\stackapp \aStack {\subs {\aTerm} \env}} = {\stackapp {\aStack'} {\subs {\aTerm[3]} \env}}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-6.5}{$\simplBeta[*]{\stackapp {\aStack'} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env {\aStack'}}}$}}
    \begin{proof}
      \step{label-6.5.1}{$\begin{conj}\judge \aContext {\subs {\aTerm[3]} \env} \tyBool \\ \judge \aContext {\subs {\aTerm[4]} {\env}} {\aType} \\ \judge \aContext {\subs {\aTerm[5]} {\env}} {\aType} \end{conj}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-6.5.2}{$\frameJudge \aContext {\aStack'} \tyBool {\aType[1]}$}
      \begin{proof}
        \pf\ By \stepref{label-6.5.1} and inversion of \ref{pf:stack-typed}
      \end{proof}
       \step{label-6.5.3}{$\aStack'$ is simplifiable}
      \begin{proof}
        \pf\ By \stepref{label-6.2}, \stepref{label-6.3} and \ref{pf:stack-simpl}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $\aTerm[3] < \aTerm$
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ $\begin{aligned}[t]
          \stackapp \aStack {\subs {\aTerm} \env} &= {\stackapp {\aStack'} {\subs {\aTerm[3]} \env}} && \text{by \stepref{label-6.4}} \\
          &\rightsquigarrow^* \go {\scoped {\aTerm[3]} \env} {\aStack'} && \text{by \stepref{label-6.5}} \\
          &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-6.1}} \\
          &\not \rightsquigarrow && \text{by \stepref{label-6.5}}
        \end{aligned}$
    \end{proof}
  \end{proof}
  \step{label-7}{\case{$\aTerm = \tlet \aVar {\aTerm[3]} {\aTerm[4]}$ (line~\ref{go:let})}}
  \step{label-8}{\case{$\aTerm = \ttyann {\aTerm[3]} {\aType[2]}$ (line~\ref{go:annot})}}
\end{proof}

\newgeometry{top=0.5cm}
\begin{figure}
  \ocamlfrom{stack.ml}{go}
\end{figure}
\restoregeometry

\subsection{Some problems with typing stacks}

We ran into problems while trying to typecheck stacks.

Here is one example: 
$$
\tapp {(\ttyapp {(\ttyfun \aTypeVar {(\tfun \aVar \aTypeVar 
        {(\tapp {(\tapp {(\ttyapp { \square } {\aTypeVar[1]})} \aVar)} {\aVar[1]})})})} 
        \tyBool)} \true 
$$

After 2 rounds of simplification, we end up with the following stack, with $\env = \envextend {\envextend \envid \aTypeVar \tyBool} \aVar \true$.

\begin{mathpar}
\aRule 
            {\aRule 
              {\aRule
              { {\frameJudge 
                 {\aContext}
                 {\emptyStack}
                 {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}
                 {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}  \\
                {\judge {\aContext} {\aVar[1]} {\aTypeVar[1]}}
              }
              {{\frameJudge 
                {\aContext}
                {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}
                {{\aTypeVar[1]} \to {\aType[2][{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
                {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}} \\
                {\judge {\aContext} {\aVar} {\aTypeVar}}
                }
              {}}
              {\frameJudge 
              {\aContext}
              {\nonEmptyStack {\aFunFrameAll {\aVar} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}}
              {\aTypeVar \to {\aTypeVar[1]} \to {\aType[2][{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
              {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
              {}
            }
            {\frameJudge 
              {\aContext = \hasType \aVar \aTypeVar, \hasType {\aVar[1]} {\aTypeVar[1]}}
              {\nonEmptyStack {\aPolyFrameAll {\aTypeVar[1]} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}}}
              {\forall {\aTypeVar[2]}, {\aTypeVar \to {\aTypeVar[2]} \to {\aType[2]}}}
              {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
            {}
\end{mathpar}
In the example above, if you keep $\aTypeVar \mapsto \tyBool$, but change $\aVar \mapsto 42$, the 
resulting type is the same, but the stack shouldn't typecheck.
The problem is that we are not using substitutions while typechecking our stacks.

So we changed the rules to include the substitutions on the terms before checking them, and on the environement.

With those rules, we can accuratly typecheck the following example: \\
$$\ttyapp {(\ttyfun \aTypeVar {\ttyapp {(\ttyapp {(\ttyfun {\aTypeVar[1]} {\ttyapp {\square} {\aTypeVar[1]}})} \tyBool)} \aTypeVar})} {\mathbb{N}}$$

\begin{mathpar}
\aRule 
  {\aRule 
    {\frameJudge 
      {\subs {\subs {\aContext} {\env[2]}} {\env[3]}}
      {\emptyStack}
      {{\subs {\aTypeVar} {\env[3]}} \times {\subs {\aTypeVar[1]} {\env[2]}}}
      {\mathbb{N} \times \tyBool}}
    {\frameJudge 
      {\subs {\aContext} {{\env[2]}}}
      {\square \: \scoped {\aTypeVar} {{\env[3]} = \aTypeVar \mapsto \mathbb{N}} : \emptyStack}
      {\forall {\aType[3]} {{{\aType[3]} \times {\subs {\aTypeVar[1]} {\env[2]}}}}}
      {\mathbb{N} \times \tyBool}}
    {}}
  {\frameJudge 
    {\aContext = \aTypeVar, {\aTypeVar[1]}}
    {{\square \: \scoped {\aTypeVar[1]} {{\env[2]} = \envid, \aTypeVar \mapsto \mathbb{N}, {\aTypeVar[1]} \mapsto \tyBool}} : {\square \: \scoped {\aTypeVar} {{\env[3]} = \aTypeVar \mapsto \mathbb{N}}} : \emptyStack}
    {\forall {\aType[2]} {\forall {\aType[3]} {{{\aType[3]} \times {\aType[2]}}}}}
    {\mathbb{N} \times \tyBool}} 
  {}
\end{mathpar}


\subsection{Lemma A}
\begin{proof}
    \pflet
    {\begin{enumerate}
        \item $\aContext$ be a context
        \item $\aTerm$ and $\aTerm'$ be terms
        \item $\aType[1]$ be a type
    \end{enumerate}}
    \assume{
        \begin{enumerate}
        \item $\judge \aContext \aTerm {\aType[1]}$ \label{lA:H1}
        \item $\simplBeta \aTerm {\aTerm'}$ \label{lA:H2}
        \end{enumerate}}
    \prove{$\judge \aContext {\aTerm'} {\aType[1]}$}
    \pfsketch\ Proof by induction on $\simplBeta \aTerm {\aTerm'}$.
    \step{label-1}{\case{$\aRule   { }
                                    {\simplBeta {\tapp {(\tfun \aVar \aType {\aTerm[3]})} \aBase} {{\subs {\aTerm[3]} {\envextend \envid \aVar {\aBase}}}}}
                                    { }$}}
    \begin{proof}
        \step{label-1.1}{\begin{enumerate}
                        \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[3]} {\aType[1]}$
                        \item $\judge \aContext \aBase {\aType}$
                        \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} twice.
        \end{proof}
        \qedstep
        \begin{proof}
           \pf\ \aRule  {\text{by substitution lemma and {\stepref{label-1.1}}}}
                    {\judge {\aContext}
                            {\subs{\aTerm[3]}{\envextend \envid \aVar \aBase}}
                            {\aType[1]}}
                    {}
        \end{proof}
    \end{proof}
    \step{label-2}{\case{$\aRule    { }
                                    {\simplBeta {\ttyapp {(\ttyfun \aTypeVar {\aTerm[3]})} {\aType}} {{\subs {\aTerm[3]} {\envextend \envid \aTypeVar {\aType}}}}}
                                    { }$}}
    \begin{proof}
        \step{label-2.1}{$\exists \aType[1]'$ such that $\begin{conj}
          \aType[1] = \subs {\aType[1]'} {\envextend \envid \aTypeVar {\aType}} \\
          \judge {\ctxtExtend{\aContext}{\aTypeVar}{\aType}} {\aTerm[3]} {\aType[1]'} \end{conj}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} twice.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by substitution lemma and {\stepref{label-2.1}}}}
                        {\judge {\aContext}
                        {\subs{\aTerm[3]}{\envextend \envid {\aTypeVar} {\aType}}}
                        {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}
    \step{label-3}{\case{$\aRule    { }
                                    {\simplBeta {\ite \true {\aTerm[3]} {\aTerm[1]}} {\aTerm[3]}}
                                    { }$}}
    \begin{proof}
        \step{label-3.1}{$\judge {\aContext} {\aTerm[3]} {\aType[1]}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-3.1}}}}
                        {\judge {\aContext}
                        {\aTerm[3]}
                        {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}
    \step{label-4}{\case{$\aRule    { }
                                    {\simplBeta {\ite \false {\aTerm[1]} {\aTerm[3]}} {\aTerm[3]}}
                                    { }$}}
    \begin{proof}
        \pf\ Same reasoning than \stepref{label-3}
    \end{proof}

    \step{label-5}{\case{$\aRule    {\simplBeta {\subs {\aTerm[3]} {\envextend \envid \aVar \aVar}} {\aTerm[1]}}
                                    {\simplBeta {\tfun \aVar {\aType} {\aTerm[3]}} {\tfun \aVar {\aType} {\aTerm[1]}}}
                                    {}$}}
    \begin{proof}
        \step{label-5.1}{\begin{enumerate}
            \item $\judge \aContext {\tfun \aVar {\aType} {\aTerm[3]}} {\aType[1] = \aType[2] \mapsto \aType}$
            \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[3]} {\aType}$
            \item $\judge \aContext {\aVar} {\aType[2]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} and by hypothesis.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-5.1}}}}
                        {\judge {\aContext}
                            {\tfun \aVar {\aType} {\aTerm[1]}}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-6}{\case{$\aRule    {\simplBeta {\aTerm[3]} {\aTerm[1]}}
                                    {\simplBeta {\tapp {\aTerm[3]} \aBase} \tapp {\aTerm[1]} \aBase}
                                    {}$}}
    \begin{proof}
        \step{label-6.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\aType[2] \mapsto \aType}$
            \item $\judge \aContext {\aBase} {\aType[2]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-6.2}{$\judge {\aContext} {\aTerm[1]} {\aType[2] \mapsto \aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[1]}} \prec {\simplBeta{\tapp {\aTerm[3]} \aBase}{\tapp {\aTerm[1]} \aBase}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-6.2}}}} {\judge {\aContext} {\aTerm[1]} {\codToDom}} {} \\
                        \aRule {\text{by {\stepref{label-6.1}}}} {\judge \aContext \aBase {\aType}} {}}
                        {\judge {\aContext}
                            {\tapp {\aTerm[1]} \aBase}
                            {\aType[2] \mapsto \aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-7}{\case{$\aRule    {\simplBeta {\aTerm[3]} {\aTerm[3]}'}
                                    {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {{\aTerm[3]}'}} {\aTerm[1]}}
                                    {}$}}
    \begin{proof}
        \step{label-7.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\aType}$
            \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[1]} {\aType[1]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-7.2}{$\judge {\aContext} {\aTerm[3]'} {\aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[3]'}} \prec {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {{\aTerm[3]}'}} {\aTerm[1]}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-7.2}}}} {\judge {\aContext} {\aTerm[3]'} {\aType}} {} \\
                        \aRule {\text{by {\stepref{label-7.1}}}} {\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[1]} {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\tlet \aVar {{\aTerm[3]}'}}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-8}{\case{$\aRule    {\simplBeta {\subs {\aTerm[1]} {\envextend \envid \aVar \aVar}} {\aTerm[1]'}}
                                    {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {\aTerm[3]} \aTerm[1]'}}
                                    {}$}}
    \begin{proof}
        \step{label-8.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\aType}$
            \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[1]} {\aType[1]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-8.2}{$\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[1]'} {\aType[1]}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[1]}{\aTerm[1]'}} \prec {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {\aTerm[3]}} {\aTerm[1]'}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-8.1}}}} {\judge {\aContext} {\aTerm[3]} {\aType}} {} \\
                        \aRule {\text{by {\stepref{label-8.2}}} and substitution lemma} {\judge {\ctxtExtend{\aContext}{\aVar}{\aType}} {\aTerm[1]'} {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\tlet \aVar {\aTerm[3]} {\aTerm[1]'}}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}

  \step{label-9}{\case{$\aRule  {\simplBeta {\aTerm[3]} {\aTerm[3]'}}
                                {\simplBeta {\ite {\aTerm[3]} {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm[3]'} {\aTerm[1]} {\aTerm[2]}}}
                                {}$}}
    \begin{proof}
        \step{label-9.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\tyBool}$
            \item $\judge {\aContext} {\aTerm[1]} {\aType[1]}$
            \item $\judge {\aContext} {\aTerm[2]} {\aType[1]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-9.2}{$\judge {\aContext} {\aTerm[3]'} {\tyBool}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[3]'}} \prec {\simplBeta {\ite {\aTerm[3]} {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm[3]'} {\aTerm[1]} {\aTerm[2]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-9.2}}}} {\judge {\aContext} {\aTerm[3]'} {\tyBool}} {} \\
                        \aRule {\text{by {\stepref{label-9.1}}}} {\judge {\aContext} {\aTerm[1]} {\aType[1]}} {} \\
                        \aRule {\text{by {\stepref{label-9.1}}}} {\judge {\aContext} {\aTerm[2]} {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\ite {\aTerm[3]'} {\aTerm[1]} {\aTerm[2]}}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-10}{\case{$\aRule   {\simplBeta {\aTerm[1]} {\aTerm[1]'}}
                                    {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]'} {\aTerm[2]} }}
                                    {} $}}
    \begin{proof}
        \step{label-10.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\tyBool}$
            \item $\judge {\aContext} {\aTerm[1]} {\aType[1]}$
            \item $\judge {\aContext} {\aTerm[2]} {\aType[1]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-10.2}{$\judge {\aContext} {\aTerm[1]'} {\aType[1]}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[1]}{\aTerm[1]'}} \prec {\simplBeta {\ite {\aTerm[3]} {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm[3]} {\aTerm[1]'} {\aTerm[2]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-10.1}}}} {\judge {\aContext} {\aTerm[3]} {\tyBool}} {} \\
                        \aRule {\text{by {\stepref{label-10.2}}}} {\judge {\aContext} {\aTerm[1]'} {\aType[1]}} {} \\
                        \aRule {\text{by {\stepref{label-10.1}}}} {\judge {\aContext} {\aTerm[2]} {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\ite {\aTerm[3]} {\aTerm[1]'} {\aTerm[2]}}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-11}{\case{$\aRule   {\simplBeta {\aTerm[2]} {\aTerm[2]'}}
                                    {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]} {\aTerm[2]'} }}
                                    {} $}}
    \begin{proof}
        \pf\ same reasoning than \stepref{label-10}
    \end{proof}


    \step{label-12}{\case{$\aRule   {\simplBeta {\subs {\aTerm[3]} {\envextend \envid \aTypeVar \aTypeVar}} {\aTerm[1]}}
                                    {\simplBeta {\ttyfun \aTypeVar {\aTerm[3]}} {\ttyfun \aTypeVar {\aTerm[1]}}}
                                    {}$}}
    \begin{proof}
        \step{label-12.1}
            {\begin{enumerate}
                \item {$\judge \aContext {\ttyfun \aTypeVar {\aTerm[3]}} {\tforall{\aTypeVar}{\aType}}$}
                \item {$\judge {\aContext, \aTypeVar} {\aTerm[3]} {\aType}$}
            \end{enumerate}}
        \begin{proof}
            \pf\ By hypothesis and inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-12.2}{$\judge {\aContext, \aTypeVar} {\aTerm[1]} {\aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[1]}} \prec {\simplBeta {\ttyfun \aTypeVar {\aTerm[3]}} {\ttyfun \aTypeVar {\aTerm[1]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-12.2}}}} {\judge {\aContext, \aTypeVar } {\aTerm[1]} {\aType}} {}}
                        {\judge {\aContext}
                            {\ttyfun \aTypeVar {\aTerm[1]}}
                            {\tforall \aTypeVar {\aType}}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-13}{\case{$\aRule   {\simplBeta {\aTerm[3]} {\aTerm[1]}}
                                    {\simplBeta {\ttyapp {\aTerm[3]} {\aType}} {\ttyapp {\aTerm[1]} {\aType}}}
                                    {}$}}
    \begin{proof}
        \step{label-13.1}{$\judge {\aContext} {\aTerm[3]} {\tforall{\aTypeVar}{\aType[1]}}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-13.2}{$\judge {\aContext} {\aTerm[1]} {\tforall{\aTypeVar}{\aType[1]}}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[1]}} \prec {\simplBeta {\ttyapp {\aTerm[3]} {\aType}} {\ttyapp {\aTerm[1]} {\aType}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-13.2}}}} {\judge {\aContext} {\aTerm[1]} {\tforall{\aTypeVar}{\aType[1]}}} {}}
                        {\judge {\aContext}
                            {\ttyapp {\aTerm[1]} {\aType}}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-14}{\case{$\aRule   { }
                                    {\simplBeta {\ttyann {\aTerm[3]} {\aType[1]} {\aTerm[3]}}}
                                    {}$}}
    \begin{proof}
        \step{label-14.1}{$\judge {\aContext} {\aTerm[3]} {\aType[1]}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-14.1}}}}
                        {\judge {\aContext}
                            {\aTerm[3]}
                            {\aType[1]}}
                        {}
        \end{proof}
    \end{proof}
\end{proof}

\subsection{Lemma B}
\begin{proof}
  \assume{\begin{enumerate}
    \item $\judge \aContext \aTerm {\aType}$ \label{lB:H1}
    \item $\frameJudge{\aContext}{\aStack}{\aType}{\aType[1]}$ \label{lB:H2}
  \end{enumerate}}
  \prove{$\judge \aContext {\stackapp \aStack \aTerm} {\aType[1]}$}
  \pfsketch\ Proof by induction on $\frameJudge{\aContext}{\aStack}{\aType}{\aType[1]}$.
  \step{label-1}{\case{$\aRule  { }
                                {\frameJudge \aContext \emptyStack \aType {\aType}}
                                {}$}}
  \begin{proof}
    \step{label-1.1}{$\judge \aContext \aTerm \aType$}
    \begin{proof}
      \pf\ By case analysis.
    \end{proof}
    \step{label-1.2}{$\stackapp{\emptyStack}{\aTerm} = \aTerm$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \qedstep
    \begin{proof}
        \pf\ \aRule {\text{by {\stepref{label-1.1}} and \stepref{label-1.2}}}
                    {\judge {\aContext}
                    {\stackapp{\emptyStack}{\aTerm}}
                    {\aType}}
                    {}
    \end{proof}
  \end{proof}

  \step{label-2}{\case{$\aRule  {\frameJudge \aContext {\aStack'} {\aType[3]} {\aType[1]} \\
                                \judgecheck \aContext {\aType[2]} {\subs \aBase \env}}
                                {\frameJudge \aContext {(\nonEmptyStack \aFunFrame {\aStack'})} {\aType[2] \to \aType[3]} {\aType[1]}}
                                {}$}}
  \begin{proof}
    \step{label-2.1}{$\judge \aContext \aTerm {\aType[2] \to \aType[3]}$}
    \begin{proof}
      \pf\ By case analysis.
    \end{proof}
    \step{label-2.2}{$\stackapp{\aStack}{\aTerm} = \stackapp{\aStack'}{\tapp{\aTerm}{(\subs \aBase \env)}}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-2.3}{$\judge{\aContext}{\tapp{\aTerm}{(\subs \aBase \env)}}{\aType[3]}$}
    \begin{proof}
      \pf\ \aRule {\aRule {\text{by {\stepref{label-2.1}}}} {\judge \aContext \aTerm {\aType[2] \to \aType[3]}} {} \\
                  \aRule {\text{by {\stepref{label-2}}}} {\judge \aContext {\subs \aBase \env} {\aType[2]}} {}}
                  {\judge {\aContext}
                          {\tapp{\aTerm}{(\subs \aBase \env)}}
                          {\aType[3]}}
                  {}
    \end{proof}
    \step{label-2.4}{$\frameJudge{\aContext}{\aStack'}{\aType[3]}{\aType[1]}$}
    \begin{proof}
      \pf\ By \stepref{label-2}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ By \stepref{label-2.2} and IH on ${\frameJudge{\aContext}{\aStack'}{\aType[3]}{\aType[1]}} \prec {\frameJudge{\aContext}{\aStack}{\aType[2] \to \aType[3]}{\aType[1]}}$ and \stepref{label-2.3}.
    \end{proof}
  \end{proof}

  \step{label-3}{\case{$\aRule  {\frameJudge \aContext {\aStack'} {\subs {\aType[3]} {\envextend \envid \aTypeVar {\subs {\aType[2]} \env}}} {\aType[1]}}
                                {\frameJudge \aContext {(\nonEmptyStack {\aPolyFrameAll {\aType[2]} {\env}} {\aStack'})} {\tforall \aTypeVar {\aType[3]}} {\aType[1]}}
                                {}$}}
  \begin{proof}
    \step{label-3.1}{$\judge \aContext \aTerm {\tforall \aTypeVar {\aType[3]}}$}
    \begin{proof}
      \pf\ By case analysis.
    \end{proof}
    \step{label-3.2}{$\stackapp{\aStack}{\aTerm} = \stackapp{\aStack'}{\ttyapp{\aTerm}{\subs {\aType[2]} \env}}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-3.3}{$\judge{\aContext}{\ttyapp{\aTerm}{\subs {\aType[2]} \env}}{\subs {\aType[3]} {\envextend \envid \aTypeVar {\subs {\aType[2]} \env}}}$}
    \begin{proof}
      \pf\ \aRule {\aRule {\text{by {\stepref{label-3.1}}}} {\judge \aContext \aTerm {\tforall \aTypeVar {\aType[3]}}} {}}
                  {\judge {\aContext}
                      {\ttyapp{\aTerm}{\subs {\aType[2]} \env}}
                      {\subs {\aType[3]} {\envextend \envid \aTypeVar {\subs {\aType[2]} \env}}}}
                  {}
    \end{proof}
    \step{label-3.4}{$\frameJudge{\aContext}{\aStack'}{\subs {\aType[3]} {\envextend \envid \aTypeVar {\subs {\aType[2]} \env}}}{\aType[1]}$}
    \begin{proof}
      \pf\ By \stepref{label-3}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ By \stepref{label-3.2} and IH on $\frameJudge{\aContext}{\aStack'}{\subs {\aType[3]} {\envextend \envid \aTypeVar {\subs {\aType[2]} \env}}}{\aType[1]} \prec {\frameJudge{\aContext}{\aStack}{\tforall \aTypeVar {\aType[3]}}{\aType[1]}}$ and \stepref{label-3.3}.
    \end{proof}
  \end{proof}

  \step{label-4}{\case{$\aRule  {\judge \aContext {\subs {\aTerm[1]} \env} {\aType[2]} \\
                                \judge \aContext {\subs {\aTerm[2]} \env} {\aType[2]} \\
                                \frameJudge \aContext {\aStack'} {\aType[2]} {\aType[1]}}
                                {\frameJudge \aContext {(\nonEmptyStack \aIteFrame {\aStack'})} \tyBool {\aType[1]}}
                                {}$}}
  \begin{proof}
    \step{label-4.1}{$\judge \aContext \aTerm \tyBool$}
    \begin{proof}
      \pf\ By case analysis.
    \end{proof}
    \step{label-4.2}{$\stackapp{\aStack}{\aTerm} = \stackapp{\aStack'}{\ite{\aTerm}{\subs {\aTerm[1]} \env}{\subs {\aTerm[2]} \env}}$}
    \begin{proof}
      \pf\ By definition of $\stackapp {\_} {\_}$
    \end{proof}
    \step{label-4.3}{$\judge{\aContext}{\ite{\aTerm}{\subs {\aTerm[1]} \env}{\subs {\aTerm[2]} \env}}{\aType[2]}$}
    \begin{proof}
      \pf\ \aRule {\aRule {\text{by {\stepref{label-4.1}}}} {\judge \aContext \aTerm \tyBool} {} \\
                  \aRule {\text{by {\stepref{label-4}}}} {\judge \aContext {\subs {\aTerm[1]} \env} {\aType[2]}} {} \\
                  \aRule {\text{by {\stepref{label-4}}}} {\judge \aContext {\subs {\aTerm[2]} \env} {\aType[2]}} {}}
                  {\judge {\aContext}
                      {\ite{\aTerm}{\subs {\aTerm[1]} \env}{\subs {\aTerm[2]} \env}}
                      {\aType[2]}}
                  {}
    \end{proof}
    \step{label-4.4}{$\frameJudge{\aContext}{\aStack'}{\aType[2]}{\aType[1]}$}
    \begin{proof}
      \pf\ By \stepref{label-4}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ By \stepref{label-4.2} and IH on $\frameJudge{\aContext}{\aStack'}{\aType[2]}{\aType[1]} \prec {\frameJudge{\aContext}{\aStack}{\tyBool}{\aType[1]}}$ and \stepref{label-4.3}.
    \end{proof}
  \end{proof}
\end{proof}

\end{document}