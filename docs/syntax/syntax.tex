\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{pf}
\usepackage{plong}
\usepackage{listings-ocaml}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\newcommand{\TODO}[1]{\textcolor{red}{$\langle$ Pierre:}~#1\textcolor{red}{~$\rangle$}}

\begin{document}
\section{Syntax}
\subsection{Terms}
$
\begin{array}{ccll}
\aTerm, \aTerm[1], \aTerm[2] & ::= & & \\
& | & \aBase & \text{(base)} \\
& | & \tfun \aVar \aType \aTerm & \text{(abstraction)} \\
& | & \tapp \aTerm \aBase & \text{(function application)} \\
& | & \tlet \aVar \aTerm {\aTerm[1]} & \text{(let binding)} \\
& | & \ite \aTerm {\aTerm[1]} {\aTerm[2]} & \text{(conditionnal)}\\
& | & \ttyfun \aTypeVar \aTerm & \text{(type abstraction)} \\
& | & \ttyapp \aTerm \aType & \text{(type application)} \\
& | & \ttyann \aTerm \aType & \text{(type annotation)}
\end{array}
$\\
$
\begin{array}{ccll}
\aBase & ::= & & \\
& | & \aVar & \text{(variable)} \\
& | & \true & \text{(true)} \\
& | & \false & \text{(false)} \\
\end{array}
$
\subsection{Types}
$
\begin{array}{ccll}
\aType, \aType[1] & ::= & & \\
& | & \aTypeVar & \text{(type variable)} \\
& | & \tyBool & \text{(bool type)} \\
& | & \aDomType \to \aCodType & \text{(function type)} \\
& | & \tforall \aTypeVar \aType & \text{(polymorphic type)} \\
& | & \aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k} & \text{(tuples)}
\end{array}
$
\section{Free variables} \label{free-variable}
\subsection{Free type variables in type}
\begin{align*}
FV(\aTypeVar) &= \aTypeVar \\
FV(\tyBool) &= \emptyset \\
FV(\domToCod) &= FV(\aDomType) \cup FV(\aCodType) \\
FV(\tforall \aTypeVar \aType) &= FV(\aType) \setminus \{ \aTypeVar \} \\
FV(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k}) &= FV(\aType[2]) \cup FV(\aType[3]) \cup \ldots \cup FV(\aType_{k}) \\
\end{align*}
\subsection{Free variables in term}
\begin{align*}
FV(\aVar) &= \aVar \\
FV(\true) &= \emptyset \\
FV(\false) &= \emptyset \\
FV(\tfun \aVar \aType \aTerm) &= FV(\aType) \cup (FV(\aTerm) \setminus \{ \aVar \}) \\
FV(\tapp \aTerm \aBase) &= FV(\aTerm) \cup FV(\aBase) \\
FV(\tlet \aVar \aTerm {\aTerm[1]}) &= FV(\aTerm) \cup (FV(\aTerm[1]) \setminus \{\aVar\}) \\
FV(\ite \aTerm {\aTerm[1]} {\aTerm[2]}) &= FV(\aTerm) \cup FV(\aTerm[1]) \cup FV(\aTerm[2]) \\
FV(\ttyfun \aTypeVar \aTerm) &= FV(\aTerm) \setminus \{ \aTypeVar \} \\
FV(\ttyapp \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
FV(\ttyann \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
\end{align*}
\section{Scoped terms}
\subsection{Terms environnement}
$
\begin{array}{ccll}
\env & ::= & \\
& | & \envid & \text{(identity)}\\
& | & \envextend \rho \aVar \aBase & \text{(variable)} \\
& | & \envextend \rho \aTypeVar \aType & \text{(type variable)}
\end{array}
$\\
A scoped term is written $\scoped \aTerm \env$ and a scoped type is written $\scoped \aType \env$

\subsection{Well scoped} \label{well-scoped-term}
$\scoped \aTerm \env$ is well-scoped if the free variables and the free type variables from $\aTerm$ are included in the domaine of $\env$. \\
$\scoped \aType \env$ is well-scoped if the free type variables from $\aType$ are included in the domaine of $\env$.
\section{Substitution} \label{substitution}
\subsection{Type substitution}
\begin{align*}
\subs \aTypeVar \envid &= \aTypeVar \\
\subs \aTypeVar {\envextend \env \aVar \aBase} &= \subs \aTypeVar \rho \\
\subs \aTypeVar {\envextend \env {\aTypeVar[1]} \aType} &=
\begin{cases}
  \aType & \text{if } \aTypeVar = \aTypeVar[1] \\
  \subs \aTypeVar \env & \text{otherwise} \\
\end{cases} \\
\subs \tyBool \env &= \tyBool \\
\subs {(\aDomType \to \aCodType)} \env &= \subs \aDomType \env \to \subs \aCodType \env \\
\subs {(\tforall \aTypeVar \aType)} \env &= \tforall {\aTypeVar[1]} {\subs \aType {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\tforall \aTypeVar \aType) \cup FV(\env) \\
\subs {(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k})} \env &= \subs {\aType[2]} \env \tprod \subs {\aType[3]} \env \tprod \ldots \subs {\tprod \aType_{k}} \env
\end{align*}
\subsection{Term substitution}
\begin{align*}
\subs \aVar \envid &= \aVar \\
\subs \aVar {\envextend \env {\aVar[1]} \aBase} &=
\begin{cases}
  \aBase & \text{if } \aVar = \aVar[1] \\
  \subs \aVar \env & \text{otherwise}
\end{cases} \\
\subs \aVar {\envextend \env \aTypeVar \aType} &= \subs \aVar \env \\
\subs \true \env &= \true \\
\subs \false \env &= \false \\
\subs {(\tfun \aVar \aType \aTerm)} \env &= \tfun {\aVar[1]} {\subs \aType \env} {\subs \aTerm {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tfun \aVar \aType \aTerm) \cup FV(\env) \\
\subs {(\tapp \aTerm {\aTerm[1]})} \env &= \tapp {\subs \aTerm \env} {\subs {\aTerm[1]} \env} \\
\subs {(\tlet \aVar \aTerm \aTerm[1])} \env &= \tlet {\aVar[1]} {\subs \aTerm \env} {\subs {\aTerm[1]} {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tlet \aVar \aTerm \aTerm[1]) \cup FV(\env) \\
\subs {(\ite \aTerm {\aTerm[1]} {\aTerm[2]})} \env &= \ite {\subs \aTerm \env} {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env} \\
\subs {(\ttyfun \aTypeVar \aTerm)} \env &= \ttyfun {\aTypeVar[1]} {\subs \aTerm {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm) \cup FV(\env) \\
\subs {(\ttyapp \aTerm \aType)} \env &= \ttyapp {\subs \aTerm \env} {\subs \aType \env} \\
\subs {\ttyann \aTerm \aType} \env &= \ttyann {\subs \aTerm \env} {\subs \aType \env}
\end{align*}
\section{Frames and stacks}
$
\begin{array}{ccll}
\aFrame & ::= & \\
& | & \aFunFrame & \text{(applied function)} \\
& | & \aPolyFrame & \text{(instantiated polymorphism)} \\
& | & \aIteFrame & \text{(if then else)}
\end{array}
$
\newline
\newline
$
\aStack ::= \emptyStack \:|\: \nonEmptyStack \aFrame \aStack \quad \text{(stacks)}
$
\subsection{Stack evaluation} \label{stack-evaluation}
\begin{align*}
  \stackapp \emptyStack \aTerm &= \aTerm \\
  \stackapp {(\nonEmptyStack \aFunFrame \aStack)} \aTerm &= \stackapp \aStack {\tapp \aTerm \aBase} \\
  \stackapp {(\nonEmptyStack \aPolyFrame \aStack)} \aTerm &= \stackapp \aStack {\ttyapp \aTerm {\aType[1]}} \\
  \stackapp {(\nonEmptyStack \aIteFrame \aStack)} \aTerm &= \stackapp \aStack {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} \\
\end{align*}

\section{Typechecker}
\subsection{Type synthesis for terms} \label{term-typechecker}
The type synthesis judgment for terms is written
\fbox{$\judge \aContext \aTerm \aType$}
and reads "We infer the type $\aType$ for the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule  {\judgequal \aContext \aVar \aType}
        {\judge \aContext \aVar \aType}
        {Variable}

\aRule { }
       {\judge \aContext \true \tyBool}
       {True}

\aRule { }
       {\judge \aContext \false \tyBool}
       {False}

\aRule  {\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType}
        {\judge \aContext {\tfun \aVar {\aType[1]} \aTerm} \domToCod}
        {Abstraction}

\aRule   {\judge \aContext \aTerm \domToCod \\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {Function application}

\aRule   {\judge \aContext \aTerm \aType \\
          \judge {\ctxtExtend \aContext \aVar \aType} {\aTerm[1]} {\aType[1]}}
         {\judge \aContext {\tlet \aVar \aTerm {\aTerm[1]}} {\aType[1]}}
         {Let binding}

\aRule   {\judge \aContext \aTerm \tyBool \\
          \judge \aContext {\aTerm[2]} \aType \\
          \judgecheck \aContext \aType {\aTerm[3]}}
         {\judge \aContext {\ite \aTerm {\aTerm[2]} {\aTerm[3]}} \aType}
         {If then else}

\aRule   {\judge {\aContext \ctxtSep \aTypeVar} \aTerm \aType \\
          \aTypeVar \notin FV(\aContext)}
         {\judge \aContext {\ttyfun \aTypeVar \aTerm} {\tforall \aTypeVar \aType}}
         {Type abstraction}

\aRule  {\judge \aContext \aTerm {\tforall \aTypeVar \aType}}
        {\judge \aContext {\ttyapp \aTerm {\aType[1]}} {\subs \aType {\envextend \envid \aTypeVar {\aType[1]}}}}
        {Type application}

\aRule  {\judgecheck \aContext \aType \aTerm}
        {\judge \aContext {\ttyann \aTerm \aType} \aType}
        {Type annotation}
\end{mathpar}

\subsection{Type checking for terms}
The type checking judgment for terms is written
\fbox{$\judgecheck \aContext \aType \aTerm$}
and reads "We verify the type $\aType$ of the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm {\aType[1]} \\
          \judgequiv \aContext {\aType[1]} \aType}
         {\judgecheck \aContext \aType \aTerm}
         {Type checking}

\end{mathpar}
\subsection{Type synthesis for stacks} \label{stack-typechecker}
The type synthesis judgment for stacks is written
\fbox{$\frameJudge \aContext \aStack {\aType[1]} \aType$}
and reads "In the context $\aContext$, the stack $\aStack$ plugged with a term of type $\aType[1]$ has type $\aType$".
\begin{mathpar}
\aRule   { }
         {\frameJudge \aContext \emptyStack \aType \aType}
         {Empty stack}

\aRule   {\frameJudge \aContext \aStack \aType \aType[2] \\
          \judgecheck \aContext {\aType[1]} \aBase}
         {\frameJudge \aContext {(\nonEmptyStack \aFunFrame \aStack)} \domToCod \aType[2]}
         {Applied function frame}

\aRule   {\frameJudge \aContext \aStack {\subs \aType {\envextend \envid \aTypeVar {\aType[1]}}} \aType[2]}
         {\frameJudge \aContext {(\nonEmptyStack \aPolyFrame \aStack)} {\tforall \aTypeVar \aType} \aType[2]}
         {Instantiated polymorphism frame}

\aRule  {\judge \aContext {\aTerm[1]} {\aType[2]} \\
          \judgecheck \aContext {\aType[2]} {\aTerm[2]} \\
          \frameJudge \aContext \aStack {\aType[2]} \aType}
        {\frameJudge \aContext {(\nonEmptyStack \aIteFrame \aStack)} \tyBool \aType}
        {IfThenElse frame}

\end{mathpar}

\section{Simplifications}
\subsection{Beta-reduction} \label{beta-reduction}
\begin{mathpar}
\aRule   { }
         {\simplBeta {\tapp {(\tfun \aVar \aType \aTerm)} \aBase} {\subs \aTerm {\envextend \envid \aVar \aBase}}}
         {}

\aRule   { }
         {\simplBeta {\ttyapp {(\ttyfun \aTypeVar \aTerm)} \aType} {\subs \aTerm {\envextend \envid \aTypeVar \aType}}}
         {}

\aRule   { }
         {\simplBeta {\ite \true \aTerm {\aTerm[1]}} \aTerm}
         {}

\aRule   { }
         {\simplBeta {\ite \false \aTerm {\aTerm[1]}} {\aTerm[1]}}
         {}

\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aVar {\aVar[1]}}} {\aTerm[1]} \\
          \aVar[1] \notin FV(\tfun \aVar \aType \aTerm)}
         {\simplBeta {\tfun \aVar \aType \aTerm} {\tfun {\aVar[1]} \aType {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\tapp \aTerm \aBase} {\tapp {\aTerm[1]} \aBase}}
         {}

\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aVar {\aVar[1]}}} {\aTerm'} \\
          \simplBeta {\aTerm[1]} {\aTerm[1]'} \\
          \aVar[1] \notin FV(\tlet \aVar \aTerm {\aTerm[1]})}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet {\aVar[1]} {\aTerm'} {\aTerm[1]'}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'} \\
          \simplBeta {\aTerm[1]} {\aTerm[1]'} \\
          \simplBeta {\aTerm[2]} {\aTerm[2]'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm'} {\aTerm[1]'} {\aTerm[2]'}}}
         {}

\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aTypeVar {\aTypeVar[1]}}} {\aTerm[1]} \\
          \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm)}
         {\simplBeta {\ttyfun \aTypeVar \aTerm} {\ttyfun {\aTypeVar[1]} {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\ttyapp \aTerm \aType} {\ttyapp {\aTerm[1]} \aType}}
         {}

\aRule   { }
         {\simplBeta {\ttyann \aTerm \aType} \aTerm}
         {}

\end{mathpar}
\subsection{Correctness}
\begin{proof}
  \pflet{$\Gamma$ a context} %item
  \pflet{$\scoped \aTerm \env$ a well-scoped term}
  \pflet{$\aStack$ a fully-simplified stack}
  \assume{$\exists \aType. \exists \aType[1]
    \begin{conj}
      \judge \Gamma {\subs \aTerm \env} \aType \\
      \frameJudge \Gamma \aStack \aType {\aType[1]}
    \end{conj}$}
  \prove{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\go {\scoped \aTerm \env} \aStack}}$ and $\judge \Gamma {\go {\scoped \aTerm \env} \aStack} {\aType[1]}$}
  \pfsketch\ Proof by induction on $\aTerm$
  \step{label-1}{\case{$\aTerm = \aBase$ (line~\ref{go:base})}}
  \begin{proof}
    \step{label-1.1}{\case{$\subs \aBase \env = \true$ and $\aStack = \nonEmptyStack \aIteFrame {\aStack'}$}}
    \begin{proof}
      \step{label-1.1.1}{$\go {\scoped \aBase \env} {(\nonEmptyStack \aIteFrame {\aStack'})} = \stackapp {\aStack'} {\aTerm[1]}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.1.2}{$\betaNormal {\stackapp {\aStack'} {\aTerm[1]}}$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:term-in-stack} and definition of $\rightsquigarrow$ \ref{beta-reduction}
      \end{proof}
      \step{label-1.1.3}{$\simplBeta {\stackapp {(\nonEmptyStack \aIteFrame {\aStack'})} \true} {\stackapp {\aStack'} {\aTerm[1]}}$}
      \begin{proof}
        \pf\ By definition of stack evaluation \ref{stack-evaluation} and $\rightsquigarrow$
      \end{proof}
      \step{label-1.1.4}{$\stackapp {\aStack'} {\aTerm[1]}$ has the type of $\stackapp {(\nonEmptyStack \aIteFrame {\aStack'})} \true$ in the context $\Gamma$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-typed},
        $\aRule {\judge \Gamma {\aTerm[1]} {\aType[2]} \\ \judgecheck \Gamma {\aType[2]} {\aTerm[2]} \\ \frameJudge \Gamma {\aStack'} {\aType[2]} \aType} {\frameJudge \Gamma {(\nonEmptyStack \aIteFrame {\aStack'})} \tyBool \aType} {}$
      \end{proof}
    \end{proof}
    \step{label-1.2}{\case{$\subs \aBase \env = \false$ and $\aStack = \nonEmptyStack \aIteFrame {\aStack'}$}}
    \begin{proof}
      \step{label-1.2.1}{$\go {\scoped \aBase \env} {(\nonEmptyStack \aIteFrame {\aStack'})} = \stackapp {\aStack'} {\aTerm[2]}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.2.2}{$\betaNormal {\stackapp {\aStack'} {\aTerm[2]}}$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:term-in-stack} and definition of $\rightsquigarrow$
      \end{proof}
      \step{label-1.2.3}{$\simplBeta {\stackapp {(\nonEmptyStack \aIteFrame {\aStack'})} \false} {\stackapp {\aStack'} {\aTerm[2]}} $}
      \begin{proof}
        \pf\ By definition of stack evaluation and $\rightsquigarrow$
      \end{proof}
      \step{label-1.1.4}{$\stackapp {\aStack'} {\aTerm[2]}$ has the type of $\stackapp {(\nonEmptyStack \aIteFrame {\aStack'})} \false$ in the context $\Gamma$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-typed},
        $\aRule {\judge \Gamma {\aTerm[1]} {\aType[2]} \\ \judgecheck \Gamma {\aType[2]} {\aTerm[2]} \\ \frameJudge \Gamma {\aStack'} {\aType[2]} \aType} {\frameJudge \Gamma {(\nonEmptyStack \aIteFrame {\aStack'})} \tyBool \aType} {}$
      \end{proof}
    \end{proof}
    \step{label-1.3}{\case{Else}}
    \begin{proof}
      \step{label-1.3.1}{$\go {\scoped \aBase \env} \aStack = \stackapp \aStack {\subs \aBase \env}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.3.2}{$\stackapp \aStack {\subs \aBase \env}$ is well-typed in the context $\Gamma$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-typed}
      \end{proof}
      \step{label-1.3.3}{$\betaNormal {\stackapp \aStack {\subs \aBase \env}}$}
      \begin{proof}
        \pf\ By definition of stack evaluation and $\rightsquigarrow$
      \end{proof}
      \step{label-1.3.4}{$\stackapp \aStack {\subs \aBase \env}$ has the type of $\stackapp \aStack {\subs \aBase \env}$ in the context $\Gamma$}
    \end{proof}
  \end{proof}
  \step{label-2}{\case{$\aTerm = (\tfun \aVar \aType {\aTerm[3]})$}}
  \begin{proof}
    \step{label-2.1}{\case{$\aStack = \nonEmptyStack \aFunFrame {\aStack'}$ (line~\ref{go:fun-holefun})}}
    \begin{proof}
      \step{label-2.1.1}{$\go {\scoped {(\tfun \aVar \aType {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aStack'}}}$}
      \begin{proof}
        \step{label-2.1.2.1}{$\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}$ is well scoped}
        \begin{proof}
          \step{label-2.1.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm) \cup \{ x \}$}
          \begin{proof}
            \pf\ By the definition of free variables \ref{free-variable}
          \end{proof}
          \qedstep
          \begin{proof}
            \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
          \end{proof}
        \end{proof}
        \step{label-2.1.2.2}{$\forall \aTerm' \in \aStack', \betaNormal {\aTerm'}$}
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-in-stack}
        \end{proof}
        \step{label-2.1.2.3}{$\subs {\aTerm[3]} {\envextend \env \aVar \aBase}$ is well-typed in the context $\Gamma$}
        \begin{proof}
          \step{label-2.1.2.3.1}{$\judge {\ctxtExtend \aContext {\aVar[1]} {\subs \aType \env}} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \aType[3]$ with $\aVar[1] \notin FV(t) \cup FV(\env)$}
          \begin{proof}
            \pf\ By substitution and \toplevel:\ref{pf:term-typed},
            $\aRule {\judge {\ctxtExtend \aContext {\aVar[1]} {\subs \aType \env}} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \aType[3] \\
            \aVar[1] \notin FV(t) \cup FV(\env)} {\judge \Gamma {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env} {{\subs \aType \env} \to \aType[3]}} {}$ 
          \end{proof}
          \step{label-2.1.2.3.2}{$\judge \Gamma \aBase {\subs \aType \env}$}
          \begin{proof}
            \pf\ By \toplevel:\ref{pf:stack-typed},
            $\aRule {\frameJudge \Gamma {\aStack'} {\aType[3]} {\aType[2]} \\ \judgecheck \Gamma {\subs \aType \env} \aBase}
            {\frameJudge \Gamma {\nonEmptyStack \aFunFrame {\aStack'}} {{\subs \aType \env} \to {\aType[3]}} {\aType[2]}} {}$
          \end{proof}
          \step{label-2.1.2.3.3}{$\judge \Gamma {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aType[3]}$}
          \begin{proof}
            \pf\ By term typechecker
          \end{proof}
        \end{proof}
        \step{label-2.1.2.4}{$\aStack'$ is well-typed in the context $\Gamma$ for the type of $\subs {\aTerm[3]} {\envextend \env \aVar \aBase}$}
        \begin{proof}
          \step{label-2.1.2.4.1}{$\judge \Gamma {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aType[3]}$}
          \begin{proof}
            \pf\ By \stepref{label-2.1.2.3}
          \end{proof}
          \step{label-2.1.2.4.2}{$\frameJudge \Gamma {\aStack'} {\aType[3]} {\aType[2]}$}
          \begin{proof}
            \pf\ By \toplevel:\ref{pf:stack-typed},
            $\aRule {\frameJudge \Gamma {\aStack'} {\aType[3]} {\aType[2]} \\ \judgecheck \Gamma {\subs \aType \env} \aBase}
            {\frameJudge \Gamma {\nonEmptyStack \aFunFrame {\aStack'}} {{\subs \aType \env} \to {\aType[3]}} {\aType[2]}} {}$
          \end{proof}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH
        \end{proof}
      \end{proof}
      \step{label-2.1.3}{$\simplBeta {\stackapp {(\nonEmptyStack \aFunFrame {\aStack'})} {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env}}{\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}}}$}
      \begin{proof}
        \pf\ \\
        $\begin{aligned}[t]
          & \stackapp {(\nonEmptyStack \aFunFrame {\aStack'})} {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env} \\
          & = \stackapp {\aStack'} {\tapp {(\subs {(\tfun \aVar \aType {\aTerm[3]})} \env)} \aBase} \\
          & = \stackapp {\aStack'} {\tapp {(\tfun {\aVar[1]} {\subs \aType \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} \aBase } \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env) \\
          & \rightsquigarrow \stackapp {\aStack'} {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} \aBase}} \\
          & = \stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}} \text{ as } \aVar[1] \notin FV(\env)
        \end{aligned}$
      \end{proof}
    \end{proof}
    \step{label-2.2}{\case{Else (line~\ref{go:fun-else})}}
    \begin{proof}
      \step{label-2.2.1}{$\go {\scoped {(\tfun \aVar \aType {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\tfun {\aVar[1]} {\subs \aType \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.2.2}{$\simplBeta[*] {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}$}
      \begin{proof}
        \step{label-2.2.2.1}{$\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}$ is well scoped}
        \begin{proof}
          \step{label-2.2.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm) \cup \{ x \}$}
          \begin{proof}
            \pf\ By the definition of free variables
          \end{proof}
          \qedstep
          \begin{proof}
            \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term
          \end{proof}
        \end{proof}
        \step{label-2.2.2.2}{$\forall \aTerm' \in \emptyStack, \betaNormal {\aTerm'}$}
        \begin{proof}
          \pf\ By the definition of well scoped stack
        \end{proof}
        \step{label-2.2.2.3}{$\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}$ is well-typed in the context $\ctxtExtend {\Gamma \setminus \hasType \aVar \aType} {\aVar[1]} \aType$}
        \begin{proof}
          \pf\ Rename a variable doesn't change types
        \end{proof}
        \step{label-2.2.2.4}{$\emptyStack$ is well-typed in the context $\ctxtExtend {\Gamma \setminus \hasType \aVar \aType} {\aVar[1]} \aType$ for the type of $\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}$}
        \begin{proof}
          \pf\ By empty stack rule \ref{stack-typechecker}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH
        \end{proof}
      \end{proof}
      \step{label-2.2.3}{$\simplBeta[*] {\stackapp \aStack {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env}} {\stackapp \aStack {\tfun {\aVar[1]} {\subs \aType \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}}$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \begin{proof}
        \pf\ By substitution~\ref{substitution} and definition of $\rightsquigarrow^*$
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aTerm = \ttyfun \aTypeVar {\aTerm[3]}$}}
  \begin{proof}
    \step{label-3.1}{\case{$\aStack = \nonEmptyStack \aPolyFrame {\aStack'}$ (line~\ref{go:tyfun-holetype})}}
    \begin{proof}
      \step{label-3.1.1}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}} {\aStack'}$}
      \step{label-3.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}} {\aStack'}}}$}
      \step{label-3.1.3}{$\simplBeta{\stackapp {(\nonEmptyStack \aPolyFrame {\aStack'})} {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env}} {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}}}$}
    \end{proof}
    \step{label-3.2}{\case{Else (line~\ref{go:tyfun-else})}}
    \begin{proof}
      \step{label-3.2.1}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \step{label-3.2.2}{$\simplBeta[*] {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$}
      \step{label-3.2.3}{$\simplBeta[*] {\stackapp \aStack {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env}} {\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\aTerm[2]}}}$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$ and $\simplBeta[*] {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} {\aTerm[2]}$}
    \end{proof}
  \end{proof}
  \step{label-4}{\case{$\aTerm = \tapp {\aTerm[3]} {\aBase}$ (line~\ref{go:funApply})}}
  \begin{proof}
    \step{label-4.1}{$\go {\scoped {(\tapp {\aTerm[3]} \aBase)} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-4.2}{$\simplBeta[*] {\stackapp {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} {\subs {\aTerm[3]} \env}} \betaNormal{{\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)}}}$}
    \begin{proof}
      \step{label-4.2.1}{$\scoped {\aTerm[3]} \env$ is well scoped}
      \begin{proof}
        \step{label-4.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm)$}
        \begin{proof}
          \pf\ By the definition of free variables \ref{free-variable}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
        \end{proof}
      \end{proof}
      \step{label-4.2.2}{$\forall \aTerm' \in (\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack), \betaNormal{\aTerm'}$}
      \begin{proof}
        \step{label-4.2.2.1}{$\betaNormal{\subs \aBase \env}$}
        \begin{proof}
          \pf\ By the definition of substitution \ref{substitution} and $\rightsquigarrow$ \ref{beta-reduction}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-in-stack}
        \end{proof}
      \end{proof}
      \step{label-4.2.3}{$\subs {\aTerm[3]} \env$ is well-typed in the context $\Gamma$}
      \begin{proof}
        \pf\ By substitution and \toplevel:\ref{pf:term-typed},
        $\aRule {\judge \Gamma {\subs {\aTerm[3]} \env} {\aType[1] \to \aType}\\ \judgecheck \Gamma {\aType[1]} {\subs \aBase \env}} {\judge \Gamma {\subs {(\tapp {\aTerm[3]} \aBase)} \env} \aType} {}$
      \end{proof}
      \step{label-4.2.4}{$\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack$ is well-typed in the context $\Gamma$ for the type of $\subs {\aTerm[3]} \env$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-typed} \\
        $\aRule {\frameJudge \Gamma \aStack \aType {\aType[2]} \\ \judgecheck \Gamma {\aType[1]} {\subs \aBase \env}} {\frameJudge \Gamma {\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack} {\aType[1] \to \aType} {\aType[2]}} {}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH
      \end{proof}
    \end{proof}
    \step{label-4.3}{$\stackapp \aStack {\subs {(\tapp {\aTerm[3]} {\aBase})} \env} = \stackapp {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} {\subs {\aTerm[3]} \env}$}
    \begin{proof}
      \pf\ By the definition of substitution and stack evaluation~\ref{stack-evaluation}
    \end{proof}
  \end{proof}
  \step{label-5}{\case{$\aTerm = \ttyapp {\aTerm[3]} {\aType[1]}$ (line~\ref{go:typeApply})}}
  \begin{proof}
    \step{label-5.1}{$\go {\scoped {(\ttyapp {\aTerm[3]} {\aType[1]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)}}$}
    \step{label-5.2}{$\simplBeta[*] {\stackapp {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)}}}$}
    \step{label-5.3}{$\stackapp \aStack {\subs {(\ttyapp {\aTerm[3]} {\aType[1]})} \env} = \stackapp {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)} {\subs {\aTerm[3]} \env}$}
  \end{proof}
  \step{label-6}{\case{$\aTerm = \ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]}$ (line~\ref{go:ite})}}
  \begin{proof}
    \step{label-6.1}{$\go {\scoped {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack)}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-6.2}{$\simplBeta{\subs {\aTerm[4]} \env} {\betaNormal{\go {\scoped {\aTerm[4]} \env} \emptyStack}}$} \label{pf:6-2}
    \begin{proof}
      \step{label-6.2.1}{$\scoped {\aTerm[4]} \env$ is well scoped}
      \begin{proof}
        \step{label-6.2.1.1}{$FV(\aTerm[4]) \subseteq FV(\aTerm) \cup \{ x \}$}
        \begin{proof}
          \pf\ By the definition of free variables
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term
        \end{proof}
      \end{proof}
      \step{label-6.2.2}{$\forall \aTerm' \in \emptyStack, \betaNormal{\aTerm'}$}
      \begin{proof}
        \pf\ By the definition of well scoped stack
      \end{proof}
      \step{label-6.2.3}{$\subs {\aTerm[4]} \env$ is well-typed in the context $\Gamma$}
      \begin{proof}
        \begin{proof}
          \pf\ By substitution and \toplevel:\ref{pf:term-typed},
          $\aRule {\judge \Gamma {\subs {\aTerm[3]} \env} {\tyBool}\\ \judge \Gamma {\subs {\aTerm[4]} \env} \aType \\ \judgecheck \Gamma \aType {\subs {\aTerm[5]} \env}} {\judge \Gamma {\subs {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aType} {}$
        \end{proof}
      \end{proof}
      \step{label-6.2.4}{$\emptyStack$ is well-typed in the context $\Gamma$ for the type of $\subs {\aTerm[4]} \env$}
      \begin{proof}
        \pf\ By empty stack rule \ref{stack-typechecker}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH
      \end{proof}
    \end{proof}
    \step{label-6.3}{$\simplBeta{\subs {\aTerm[5]} \env} {\betaNormal{\go {\scoped {\aTerm[5]} \env} \emptyStack}}$}
    \step{label-6.4}{$\simplBeta[*]{\stackapp {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack)} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack)}}}}$}
    \begin{proof}
      \step{label-6.4.1}{$\scoped {\aTerm[3]} \env$ is well scoped}
      \begin{proof}
        \step{label-6.4.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm)$}
        \begin{proof}
          \pf\ By the definition of free variables \ref{free-variable}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
        \end{proof}
      \end{proof}
      \step{label-6.4.2}{$\forall \aTerm' \in (\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack), \betaNormal{\aTerm'}$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:term-in-stack}, \stepref{label-6.2} and \stepref{label-6.3}
      \end{proof}
      \step{label-6.4.3}{$\subs {\aTerm[3]} \env$ is well-typed in the context $\Gamma$}
      \begin{proof}
        \pf\ By substitution and \toplevel:\ref{pf:term-typed},
        $\aRule {\judge \Gamma {\subs {\aTerm[3]} \env} {\tyBool}\\ \judge \Gamma {\subs {\aTerm[4]} \env} \aType \\ \judgecheck \Gamma \aType {\subs {\aTerm[5]} \env}} {\judge \Gamma {\subs {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aType} {}$
      \end{proof}
      \step{label-6.4.4}{$\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack$ is well-typed in the context $\Gamma$ for the type of $\subs {\aTerm[3]} \env$}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-typed}, 
        $\aRule {\judge \Gamma {\go {\scoped {\aTerm[4]} \env} \emptyStack} {\aType[3]} \\ \judgecheck \Gamma {\aType[3]} {\go {\scoped {\aTerm[5]} \env} \emptyStack} \\ \frameJudge \Gamma \aStack {\aType[3]} \aType} {\frameJudge \Gamma {\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack} {\tyBool} \aType} {}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH
      \end{proof}
    \end{proof}
    \step{label-6.5}{$\simplBeta[*]{\stackapp \aStack {\subs {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env}} {\stackapp {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)}} \aStack)} {\subs {\aTerm[3]} \env}}$}
    \begin{proof}
      \pf\ By substitution, $\rightsquigarrow^*$ and stack evaluation
    \end{proof}
  \end{proof}
  \step{label-7}{\case{$\aTerm = \tlet \aVar {\aTerm[3]} {\aTerm[4]}$ (line~\ref{go:let})}}
  \begin{proof}
    \step{label-7.1}{$\go {\scoped {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env} \aStack = \stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
    \step{label-7.2}{$\simplBeta[*] {\subs {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} {\betaNormal{\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}$}
    \step{label-7.3}{$\simplBeta[*] {\subs {\aTerm[3]} \env } {\betaNormal{\go {\scoped {\aTerm[3]} \env} \emptyStack}}$}
    \step{label-7.4}{$\simplBeta[*] {\stackapp \aStack {\subs {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env}} {\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}} \text{ with } \aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
  \end{proof}
  \step{label-8}{\case{$\aTerm = \ttyann {\aTerm[3]} \aType$ (line~\ref{go:annot})}}
  \begin{proof}
    \step{label-8.1}{$\go {\scoped {\ttyann {\aTerm[3]} \aType} \env} \aStack = \go {\scoped {\aTerm[3]} \env} \aStack$}
    \step{label-8.2}{$\simplBeta[*] {\stackapp \aStack {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env} \aStack}}$}
    \step{label-8.3}{$\simplBeta{\stackapp \aStack {\subs {\ttyann {\aTerm[3]} \aType} \env}} {\stackapp \aStack {\subs {\aTerm[3]} \env}}$}
  \end{proof}
\end{proof}

\newgeometry{top=0.5cm}
\begin{figure}
  \ocamlfrom{stack.ml}{go}
\end{figure}
\restoregeometry

\end{document}
