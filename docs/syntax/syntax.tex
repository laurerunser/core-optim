\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{pf}
\usepackage{plong}
\usepackage{listings-ocaml}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\newcommand{\TODO}[1]{\textcolor{red}{$\langle$ Pierre:}~#1\textcolor{red}{~$\rangle$}}

\begin{document}
\section{Syntax}
\subsection{Terms}
$
\begin{array}{ccll}
\aTerm, \aTerm[1], \aTerm[2] & ::= & & \\
& | & \aBase & \text{(base)} \\
& | & \tfun \aVar \aType \aTerm & \text{(abstraction)} \\
& | & \tapp \aTerm \aBase & \text{(function application)} \\
& | & \tlet \aVar \aTerm {\aTerm[1]} & \text{(let binding)} \\
& | & \ite \aTerm {\aTerm[1]} {\aTerm[2]} & \text{(conditionnal)}\\
& | & \ttyfun \aTypeVar \aTerm & \text{(type abstraction)} \\
& | & \ttyapp \aTerm \aType & \text{(type application)} \\
& | & \ttyann \aTerm \aType & \text{(type annotation)}
\end{array}
$\\
$
\begin{array}{ccll}
\aBase & ::= & & \\
& | & \aVar & \text{(variable)} \\
& | & \true & \text{(true)} \\
& | & \false & \text{(false)} \\
\end{array}
$
\subsection{Types}
$
\begin{array}{ccll}
\aType, \aType[1] & ::= & & \\
& | & \aTypeVar & \text{(type variable)} \\
& | & \tyBool & \text{(bool type)} \\
& | & \aDomType \to \aCodType & \text{(function type)} \\
& | & \tforall \aTypeVar \aType & \text{(polymorphic type)} \\
& | & \aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k} & \text{(tuples)}
\end{array}
$
\section{Free variables} \label{free-variable}
\subsection{Free type variables in type}
\begin{align*}
FV(\aTypeVar) &= \aTypeVar \\
FV(\tyBool) &= \emptyset \\
FV(\domToCod) &= FV(\aDomType) \cup FV(\aCodType) \\
FV(\tforall \aTypeVar \aType) &= FV(\aType) \setminus \{ \aTypeVar \} \\
FV(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k}) &= FV(\aType[2]) \cup FV(\aType[3]) \cup \ldots \cup FV(\aType_{k}) \\
\end{align*}
\subsection{Free variables in term}
\begin{align*}
FV(\aVar) &= \aVar \\
FV(\true) &= \emptyset \\
FV(\false) &= \emptyset \\
FV(\tfun \aVar \aType \aTerm) &= FV(\aType) \cup (FV(\aTerm) \setminus \{ \aVar \}) \\
FV(\tapp \aTerm \aBase) &= FV(\aTerm) \cup FV(\aBase) \\
FV(\tlet \aVar \aTerm {\aTerm[1]}) &= FV(\aTerm) \cup (FV(\aTerm[1]) \setminus \{\aVar\}) \\
FV(\ite \aTerm {\aTerm[1]} {\aTerm[2]}) &= FV(\aTerm) \cup FV(\aTerm[1]) \cup FV(\aTerm[2]) \\
FV(\ttyfun \aTypeVar \aTerm) &= FV(\aTerm) \setminus \{ \aTypeVar \} \\
FV(\ttyapp \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
FV(\ttyann \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
\end{align*}
\section{Scoped terms}
\subsection{Terms environnement}
$
\begin{array}{ccll}
\env & ::= & \\
& | & \envid & \text{(identity)}\\
& | & \envextend \rho \aVar \aBase & \text{(variable)} \\
& | & \envextend \rho \aTypeVar \aType & \text{(type variable)}
\end{array}
$\\
We will write $\scoped \aTerm \env$ to denote the pair of the term $\aTerm$ and its environment $\env$.  \\
Similarly, $\scoped \aType \env$ denotes the pair of the type $\aType$ and its environment $\env$. \\

\subsection{Substitution} \label{substitution}
\subsubsection{Type substitution}
\begin{align*}
\subs \aTypeVar \envid &= \aTypeVar \\
\subs \aTypeVar {\envextend \env \aVar \aBase} &= \subs \aTypeVar \rho \\
\subs \aTypeVar {\envextend \env {\aTypeVar[1]} \aType} &=
\begin{cases}
  \aType & \text{if } \aTypeVar = \aTypeVar[1] \\
  \subs \aTypeVar \env & \text{otherwise} \\
\end{cases} \\
\subs \tyBool \env &= \tyBool \\
\subs {(\aDomType \to \aCodType)} \env &= \subs \aDomType \env \to \subs \aCodType \env \\
\subs {(\tforall \aTypeVar \aType)} \env &= \tforall {\aTypeVar[1]} {\subs \aType {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\tforall \aTypeVar \aType) \cup FV(\env) \\
\subs {(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k})} \env &= \subs {\aType[2]} \env \tprod \subs {\aType[3]} \env \tprod \ldots \subs {\tprod \aType_{k}} \env
\end{align*}
\subsubsection{Term substitution}
\begin{align*}
\subs \aVar \envid &= \aVar \\
\subs \aVar {\envextend \env {\aVar[1]} \aBase} &=
\begin{cases}
  \aBase & \text{if } \aVar = \aVar[1] \\
  \subs \aVar \env & \text{otherwise}
\end{cases} \\
\subs \aVar {\envextend \env \aTypeVar \aType} &= \subs \aVar \env \\
\subs \true \env &= \true \\
\subs \false \env &= \false \\
\subs {(\tfun \aVar \aType \aTerm)} \env &= \tfun {\aVar[1]} {\subs \aType \env} {\subs \aTerm {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tfun \aVar \aType \aTerm) \cup FV(\env) \\
\subs {(\tapp \aTerm {\aTerm[1]})} \env &= \tapp {\subs \aTerm \env} {\subs {\aTerm[1]} \env} \\
\subs {(\tlet \aVar \aTerm \aTerm[1])} \env &= \tlet {\aVar[1]} {\subs \aTerm \env} {\subs {\aTerm[1]} {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tlet \aVar \aTerm \aTerm[1]) \cup FV(\env) \\
\subs {(\ite \aTerm {\aTerm[1]} {\aTerm[2]})} \env &= \ite {\subs \aTerm \env} {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env} \\
\subs {(\ttyfun \aTypeVar \aTerm)} \env &= \ttyfun {\aTypeVar[1]} {\subs \aTerm {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm) \cup FV(\env) \\
\subs {(\ttyapp \aTerm \aType)} \env &= \ttyapp {\subs \aTerm \env} {\subs \aType \env} \\
\subs {\ttyann \aTerm \aType} \env &= \ttyann {\subs \aTerm \env} {\subs \aType \env}
\end{align*}

\subsection{Domaine}
The domaine of an environment is written $D(\env)$ and is equal to $\{ \aVar ~\vert~ \exists \aBase. \aVar \ne \aBase \text{ and } \subs \aVar \env = \aBase \} \cup \{ \aTypeVar ~\vert~ \exists \aType. \aTypeVar \ne \aType \text{ and } \subs \aTypeVar \env = \aType \}$

\subsection{Well scoped} \label{well-scoped-term}
$\scoped \aTerm \env$ is well-scoped if $FV(\aTerm) \subseteq D(\env)$ \\
$\scoped \aType \env$ is well-scoped if $FV(\aType) \subseteq D(\env)$

\section{Frames and stacks}
$
\begin{array}{ccll}
\aFrame & ::= & \\
& | & \aFunFrame & \text{(applied function)} \\
& | & \aPolyFrame & \text{(instantiated polymorphism)} \\
& | & \aIteFrame & \text{(if then else)}
\end{array}
$
\newline
\newline
$
\aStack ::= \emptyStack \:|\: \nonEmptyStack \aFrame \aStack \quad \text{(stacks)}
$
\subsection{Stack application} \label{stack-application}
\begin{align*}
  \stackapp \emptyStack \aTerm &= \aTerm \\
  \stackapp {(\nonEmptyStack \aFunFrame \aStack)} \aTerm &= \stackapp \aStack {\tapp \aTerm {(\subs \aBase \env)}} \\
  \stackapp {(\nonEmptyStack \aPolyFrame \aStack)} \aTerm &= \stackapp \aStack {\ttyapp \aTerm {\subs {\aType[1]} \env}} \\
  \stackapp {(\nonEmptyStack \aIteFrame \aStack)} \aTerm &= \stackapp \aStack {\ite \aTerm {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env}} \\
\end{align*}

\section{Typechecker}
\subsection{Type synthesis for terms} \label{term-typechecker}
The type synthesis judgment for terms is written
\fbox{$\judge \aContext \aTerm \aType$}
and reads "We infer the type $\aType$ for the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule  {\judgequal \aContext \aVar \aType}
        {\judge \aContext \aVar \aType}
        {Variable}

\aRule { }
       {\judge \aContext \true \tyBool}
       {True}

\aRule { }
       {\judge \aContext \false \tyBool}
       {False}

\aRule  {\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType}
        {\judge \aContext {\tfun \aVar {\aType[1]} \aTerm} \domToCod}
        {Abstraction}

\aRule   {\judge \aContext \aTerm \domToCod \\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {Function application}

\aRule   {\judge \aContext \aTerm \aType \\
          \judge {\ctxtExtend \aContext \aVar \aType} {\aTerm[1]} {\aType[1]}}
         {\judge \aContext {\tlet \aVar \aTerm {\aTerm[1]}} {\aType[1]}}
         {Let binding}

\aRule   {\judge \aContext \aTerm \tyBool \\
          \judge \aContext {\aTerm[2]} \aType \\
          \judge \aContext {\aTerm[3]} \aType}
         {\judge \aContext {\ite \aTerm {\aTerm[2]} {\aTerm[3]}} \aType}
         {If then else}

\aRule   {\judge {\aContext \ctxtSep \aTypeVar} \aTerm \aType \\
          \aTypeVar \notin FV(\aContext)}
         {\judge \aContext {\ttyfun \aTypeVar \aTerm} {\tforall \aTypeVar \aType}}
         {Type abstraction}

\aRule  {\judge \aContext \aTerm {\tforall \aTypeVar \aType}}
        {\judge \aContext {\ttyapp \aTerm {\aType[1]}} {\subs \aType {\envextend \envid \aTypeVar {\aType[1]}}}}
        {Type application}

\aRule  {\judgecheck \aContext \aType \aTerm}
        {\judge \aContext {\ttyann \aTerm \aType} \aType}
        {Type annotation}
\end{mathpar}

\subsection{Type checking for terms}
The type checking judgment for terms is written
\fbox{$\judgecheck \aContext \aType \aTerm$}
and reads "We verify the type $\aType$ of the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm {\aType[1]} \\
          \judgequiv \aContext {\aType[1]} \aType}
         {\judgecheck \aContext \aType \aTerm}
         {Type checking}

\end{mathpar}
\subsection{Type synthesis for stacks} \label{stack-typechecker}
The type synthesis judgment for stacks is written
\fbox{$\frameJudge \aContext \aStack {\aType[1]} \aType$}
and reads "In the context $\aContext$, the stack $\aStack$ plugged with a term of type $\aType[1]$ has type $\aType$".
\begin{mathpar}
\aRule   { }
         {\frameJudge \aContext \emptyStack \aType {\aType}}
         {Empty stack}

\aRule   {\frameJudge \aContext \aStack \aType {\aType[2]} \\
          \judgecheck \aContext {\aType[1]} {\subs \aBase \env}}
         {\frameJudge \aContext {(\nonEmptyStack \aFunFrame \aStack)} \domToCod {\aType[2]}}
         {Applied function frame}

\aRule   {\frameJudge \aContext \aStack {\subs \aType {\envextend \envid \aTypeVar {\subs {\aType[1]} \env}}} {\aType[2]}}
         {\frameJudge \aContext {(\nonEmptyStack \aPolyFrame \aStack)} {\tforall \aTypeVar \aType} {\aType[2]}}
         {Instantiated polymorphism frame}

\aRule  {\judge \aContext {\subs {\aTerm[1]} \env} {\aType[2]} \\
          \judge \aContext {\subs {\aTerm[2]} \env} {\aType[2]} \\
          \frameJudge \aContext \aStack {\aType[2]} {\aType}}
        {\frameJudge \aContext {(\nonEmptyStack \aIteFrame \aStack)} \tyBool \aType}
        {IfThenElse frame}

\end{mathpar}

\section{Simplifications}
\subsection{Constant folding} \label{constant-folding}
\subsubsection{Rules}
\begin{mathpar}
\aRule   { }
         {\simplBeta {\tapp {(\tfun \aVar \aType \aTerm)} \aBase} {{\subs \aTerm {\envextend \envid \aVar \textcolor{orange}{\frak{\aBase}}}}}}
         {}

\aRule   { }
         {\simplBeta {\ttyapp {(\ttyfun \aTypeVar \aTerm)} \aType} {{\subs \aTerm {\envextend \envid \aTypeVar \textcolor{orange}{\frak{\aType}}}}}}
         {}

\aRule   { }
         {\simplBeta {{\ite \true \aTerm {\aTerm[1]}}} {\aTerm}}
         {}

\aRule   { }
         {\simplBeta {{\ite \false \aTerm {\aTerm[1]}}} {\aTerm[1]}}
         {}
\end{mathpar}
\subsubsection{Congruence rules}
\begin{mathpar}
\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aVar {\textcolor{orange}{\frak{\aVar}}}}} {\aTerm[1]}}
         {\simplBeta {\tfun \aVar \aType \aTerm} {\tfun {\textcolor{orange}{\frak{\aVar}}} \aType {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\tapp \aTerm \aBase} \tapp {\aTerm[1]} \aBase}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'}}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet \aVar {\aTerm'}} {\aTerm[1]}}
         {}

\aRule   {\simplBeta {\subs {\aTerm[1]} {\envextend \envid \aVar {\textcolor{orange}{\frak{\aVar}}}}} {\aTerm[1]'}}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet {\textcolor{orange}{\frak{\aVar}}} \aTerm \aTerm[1]'}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm'} {\aTerm[1]} {\aTerm[2]}}}
         {}

\aRule   {\simplBeta {\aTerm[1]} {\aTerm[1]'}}
          {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]'} {\aTerm[2]} }}
{}

\aRule   {\simplBeta {\aTerm[2]} {\aTerm[2]'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]} {\aTerm[2]'}}}
         {}

\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aTypeVar {\textcolor{orange}{\frak{\aTypeVar}}}}} {\aTerm[1]}}
         {\simplBeta {\ttyfun \aTypeVar \aTerm} {\ttyfun {\textcolor{orange}{\frak{\aTypeVar}}} {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\ttyapp \aTerm \aType} {\ttyapp {\aTerm[1]} \aType}}
         {}

\aRule   { }
         {\simplBeta {\ttyann \aTerm \aType} \aTerm}
         {}

\end{mathpar}
{\bf Lemma 3:} $\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType \wedge \judge \aContext \aBase {\aType[1]} \Rightarrow \judge \aContext {\subs \aTerm {\envextend \envid \aVar \aBase}} \aType$ \\
{\bf Lemma 4:} $\simplBeta \aTerm {\aTerm'} \Rightarrow \forall \aStack, \simplBeta {\stackapp \aStack \aTerm} {\stackapp \aStack {\aTerm'}}$
\subsection{Stack simplifiable}
A stack $\aStack = \nonEmptyStack {\aFrame} {\aStack'}$ is simplifiable iff forall sub-stack $\aStack''$ of $\aStack$, forall $\scoped \aTerm \env$ in $\aFrame$, if $\simplBeta[*] {\stackapp {\aStack''} {\subs \aTerm \env}} {\betaNormal{\go {\scoped \aTerm \env} \aStack}}$ \\
{\bf Lemma 5:} $\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal{\go {\scoped \aTerm \env} \aStack}} \wedge ~ \subs \aTerm \env$ stuck is $ \aStack \Rightarrow \simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal{\plug \aStack {(\subs \aTerm \env)}}}$
\subsection{Correctness}
\begin{proof}
  \pflet 
  {\begin{enumerate}
    \item $\aTerm$ be a term
    \item $\env$ be a substitution
    \item $\aStack$ be a stack
  \end{enumerate}}
  \assume{$\exists \aContext, \aType ,\aType[1]$ such that
    \begin{enumerate}
      \item $\judge \aContext {\subs \aTerm \env} \aType$ \label{pf:term-typed}
      \item $\frameJudge \aContext \aStack \aType {\aType[1]}$ \label{pf:stack-typed}
      \item $\aStack$ is simplifiable ?? \label{pf:stack-simpl}
    \end{enumerate}
    }
  \prove{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\go {\scoped \aTerm \env} \aStack}}$}
  \pfsketch\ Proof by lexicographic induction on $(\aStack, \aTerm)$.
  \step{label-1}{\case{$\aTerm = \aBase$ (line~\ref{go:base})}}
  \begin{proof}
    \step{label-1.1}{\case{$\begin{conj} \subs \aBase \env = \true \\ \aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'} \end{conj}$}}
    \begin{proof}
      \step{label-1.1.1}{$\go {\scoped \aTerm \env} \aStack = \go {\scoped {\aTerm[1]} {\env'} {\aStack'}}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} {\betaNormal {\go {\scoped {\aTerm[1]} {\env'} {\aStack'}}}}$}
      \begin{proof}
        \step{label-1.1.2.1}{$\exists \aType[2]$ such that $\begin{conj}\judge \aContext {\subs {\aTerm[1]} {\env'}} {\aType[2]} \\ \frameJudge \aContext {\aStack'} {\aType[2]} {\aType[1]} \end{conj}$}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-typed}
        \end{proof}
        \step{label-1.1.3}{$\aStack'$ is simplifiable}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH on $(\aStack', u) < (\aStack, t)$
        \end{proof}
      \end{proof}
      \step{label-1.1.3}{$\simplBeta {\stackapp \aStack {\subs \aTerm \env}} {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}}$}
      \begin{proof}
        \pf\ \\ $ \stackapp {\nonEmptyStack {\aIteFrame[\env']} {\aStack'}} {\true} \\
            \begin{aligned}[t]
            & = \stackapp {\aStack'} {\ite {\true} {\subs {\aTerm[1]} {\env'}} {\subs {\aTerm[2]} {\env'}}} && \text{by definition of $\_[\_]$} \\
            & \simplBeta {}  {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} && \text{by definition of $\rightsquigarrow$ and lemma $4$ }
        \end{aligned}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs \aBase {\env}} &\rightsquigarrow {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} && \text{by \stepref{label-1.1.3}}
            \\ &\rightsquigarrow^{*} {\go {\scoped {\aTerm[1]} {\env'}} {\aStack'}} && \text{by \stepref{label-1.1.2}}
            \\ &= {\go {\scoped {\aBase} {\env}} {\aStack}} && \text{by \stepref{label-1.1.1}}
            \\ &\not \rightsquigarrow && \text{by \stepref{label-1.1.2}}
            \end{aligned}$
      \end{proof}
    \end{proof}
    \step{label-1.2}{\case{$\subs \aBase \env = \false$ and $\aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'}$}}
    \step{label-1.3}{\case{otherwise}}
    \begin{proof}
      \step{label-1.3.1}{$\go {\scoped \aTerm \env} \aStack = \plug \aStack {(\subs \aTerm \env)}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.3.2}{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\plug \aStack {(\subs \aTerm \env)}}}$}
      \begin{proof}
        \step{label-1.3.2.1}{$\scoped \aTerm \env$ is stuck in $\aStack$}
        \begin{proof}
          \pf\ By definition of $\rightsquigarrow$ and $\_[\_]$
        \end{proof}
        \step{label-1.3.2.2}{$\aStack$ is simplifiable}
        \begin{proof}
          \pf\ By \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By lemma 5 ??
        \end{proof}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs \aTerm {\env}} &\rightsquigarrow {\plug \aStack {(\subs \aTerm \env)}} && \text{by \stepref{label-1.3.2}}
            \\ &= {\go {\scoped {\aTerm} {\env}} {\aStack}} && \text{by \stepref{label-1.3.1}}
            \\ &\not \rightsquigarrow && \text{by \stepref{label-1.3.2}}
            \end{aligned}$
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-2}{\case{$\aTerm = (\tfun \aVar {\aType[2]} {\aTerm[3]})$}}
  \begin{proof}
    \step{label-2.1}{\case{$\aStack = \nonEmptyStack {\aFunFrame[\env']} {\aStack'}$ (line~\ref{go:fun-holefun})}}
    \begin{proof}
      \pflet{$\env'' = \envextend \env \aVar {\subs \aBase {\env'}}$}
      \step{label-2.1.1}{$\go {\scoped {\aTerm} \env} \aStack = \go {\scoped {\aTerm[3]} {\env''}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\env''}} {\aStack'}}}$}
      \begin{proof}
        \step{label-2.1.2.1}{$\exists \aType[3]$ such that $\begin{conj}\aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\aContext} {\subs {\aTerm[3]} {\env''}} {\aType[3]} \\ \frameJudge {\aContext} {\aStack'} {\aType[3]} {\aType[1]} \end{conj}$}
        \begin{proof}
          \step{label-2.1.2.1.1}{$\exists \aType[3]$ such that $\begin{conj} \aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \aType[3]$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env) \end{conj}$}
          \begin{proof}
            \pf\ By substitution and inversion of \ref{pf:term-typed}
          \end{proof}
          \step{label-2.1.2.1.2}{$\judge \aContext {\subs \aBase {\env'}} {\subs {\aType[2]} \env}$ and $\frameJudge \aContext {\aStack'} {\aType[3]} {\aType[1]}$}
          \begin{proof}
            \pf\ By inversion of \ref{pf:stack-typed}
          \end{proof}
          \step{label-2.1.2.1.3}{$\judge \aContext {\subs {\aTerm[3]} {\env''}} \aType$}
          \begin{proof}
            \step{label-2.1.2.1.3.1}{$\judge \aContext {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} {\subs \aBase {\env'}}}} \aType$}
            \begin{proof}
              \pf\ By lemma 3
            \end{proof}
            \qedstep
            \begin{proof}
              \pf\ $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$
            \end{proof}
          \end{proof}
        \end{proof}
        \step{label-2.1.2.2}{$\aStack'$ is simplifiable}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH on $(\aStack', \aTerm[3]) < (\aStack, \aTerm)$
        \end{proof}
      \end{proof}
      \step{label-2.1.3}{$\simplBeta {\stackapp {\aStack} {\subs {\aTerm} \env}}{\stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}}}$}
      \begin{proof}
        \pf\ \\
          $\stackapp {(\nonEmptyStack {\aFunFrame[\env']} {\aStack'})} {(\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} (\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}}) \\
          \begin{aligned}
          & = \stackapp {\aStack'} {\tapp {(\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} {\subs \aBase {\env'}} } && \text{by definition of \_[\_]}\\
          & \rightsquigarrow \stackapp {\aStack'} {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} {\subs \aBase {\env'}}}} && \text{by definition of $\rightsquigarrow$ and lemma 4} \\
          & = \stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}} && \text{as $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
        \end{aligned}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs {\aTerm} \env}
            &\rightsquigarrow \stackapp {\aStack'} {\subs {\aTerm[3]} {\env''}} && \text{by \stepref{label-2.1.3}} \\
            &\rightsquigarrow^* \go {\scoped {\aTerm[3]} {\env''}} {\aStack'} && \text{by \stepref{label-2.1.2}} \\
            &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-2.1.1}} \\
            &\not \rightsquigarrow && \text{by \stepref{label-2.1.2}}
          \end{aligned}$
      \end{proof}
    \end{proof}
    \step{label-2.2}{\case{otherwise (line~\ref{go:fun-else})}}
    \begin{proof}
      \pflet{$\env' = \envextend \env \aVar {\aVar[1]} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \pflet{$\aTerm[3]' = \go {\scoped {\aTerm[3]} {\env'}} \emptyStack $}
      \pflet{$\aTerm' = (\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\aTerm[3]'})$}
      \step{label-2.2.1}{$\go {\scoped {\aTerm} \env} \aStack = \plug \aStack {\aTerm'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.2.2}{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\plug \aStack {\aTerm'}}}$}
      \begin{proof}
        \step{label-2.2.2.1}{$\aTerm'$ is stuck in $\aStack$}
        \begin{proof}
          \step{label-2.2.2.1.1}{$\simplBeta[*] {\stackapp {\emptyStack} {\subs {\aTerm[3]} {\env'}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\env'}} {\emptyStack}}}$}
          \begin{proof}
            \step{label-2.2.2.1.1.1}{$\exists \aContext', \aType[3]$ such that $\begin{conj}\aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\aContext'} {\subs {\aTerm[3]} {\env'}} {\aType[3]} \\ \frameJudge {\aContext'} {\emptyStack} {\aType[3]} {\aType[3]} \end{conj}$}
            \begin{proof}
              \step{label-2.2.2.1.1.1.1}{$\exists \aType[3]$ such that $\begin{conj} \aType = \subs {\aType[2]} \env \to \aType[3] \\ \judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\subs {\aTerm[3]} {\env'}} {\aType[3]} \end{conj}$}
              \begin{proof}
                \pf\ By substitution and inversion of \ref{pf:term-typed}
              \end{proof}
              \step{label-2.2.2.1.1.1.2}{$\frameJudge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\emptyStack} {\aType[3]} {\aType[3]}$}
              \begin{proof}
                \pf\ By definition
              \end{proof}
            \end{proof}
            \step{label-2.2.2.1.1.2}{$\emptyStack$ is simplifiable}
            \begin{proof}
              \pf\ ??
            \end{proof}
            \qedstep
            \begin{proof}
              \pf\ By IH on $(\emptyStack, \aTerm[3]) < (\aStack, \aTerm)$
            \end{proof}
          \end{proof}
        \end{proof}
        \step{label-2.2.2.2}{$\aStack$ is simplifiable}
        \begin{proof}
          \pf\ By \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By lemma 5 ??
        \end{proof}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ $\begin{aligned}[t]
            \stackapp \aStack {\subs {\aTerm} \env}
            &\rightsquigarrow^* {\plug \aStack {\aTerm'}} && \text{by \stepref{label-2.2.2}} \\
            &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-2.2.1}} \\
            &\not \rightsquigarrow && \text{by \stepref{label-2.2.2}}
          \end{aligned}$
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aTerm = \ttyfun \aTypeVar {\aTerm[3]}$}}
  \begin{proof}
    \step{label-3.1}{\case{$\aStack = \nonEmptyStack {\aPolyFrame[\env']} {\aStack'}$ (line~\ref{go:tyfun-holetype})}}
    \begin{proof}
      \step{label-3.1.1}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {{\subs {\aType[1]} {\env'}}}}} {\aStack'}$}
      \step{label-3.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {{\subs {\aType[1]} {\env'}}}}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {{\subs {\aType[1]} {\env'}}}}} {\aStack'}}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {{\subs {\aType[1]} {\env'}}}}} {\aStack'}} {{\subs {\aType[1]} {\env'}}}$}
      \step{label-3.1.3}{$\simplBeta{\stackapp {(\nonEmptyStack {\aPolyFrame[\env']} {\aStack'})} {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env}} {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {{\subs {\aType[1]} {\env'}}}}}}$}
    \end{proof}
    \step{label-3.2}{\case{Else (line~\ref{go:tyfun-else})}}
    \begin{proof}
      \step{label-3.2.1}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \step{label-3.2.2}{$\simplBeta[*] {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$ and $\judge {\aContext \ctxtSep \aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}} \emptyStack}} {\aType[3]}$}
      \step{label-3.2.3}{$\betaNormal{\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}}$}
      \step{label-3.2.4}{$\judge \aContext {\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}} {\aType[1]}$}
      \step{label-3.2.5}{$\simplBeta[*] {\stackapp \aStack {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env}} {\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}}$}
    \end{proof}
  \end{proof}
  \step{label-4}{\case{$\aTerm = \tapp {\aTerm[3]} {\aBase}$ (line~\ref{go:funApply})}}
  \begin{proof}
    \pflet{$\aStack' = \nonEmptyStack {\aFunFrame[\env]} \aStack$}
    \step{label-4.1}{$\go {\scoped {\aTerm} \env} \aStack = \go {\scoped {\aTerm[3]} \env {\aStack'}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-4.2}{$\stackapp \aStack {\subs {\aTerm} \env} = \stackapp {\aStack'} {\subs {\aTerm[3]} \env}$}
    \begin{proof}
      \pf\ By definition of $\_[\_]$
    \end{proof}
    \step{label-4.3}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} \env}} \betaNormal{{\go {\scoped {\aTerm[3]} \env} {\aStack'}}}$}
    \begin{proof}
      \step{label-4.3.1}{$\exists \aType[2]$ such that $\judge \aContext {\subs {\aTerm[3]} \env} {\aType[2] \to \aType}$}
      \begin{proof}
        \pf\ By substitution and inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-4.3.2}{$\aStack'$ is fully simplifiable}
      \begin{proof}
        \pf\ By \ref{pf:stack-simpl}
      \end{proof}
      \step{label-4.3.3}{$\frameJudge \aContext {\aStack'} {\aType[2] \to \aType} {\aType[1]}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-typed}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $(\aStack', \aTerm[3]) < (\aStack, \aTerm)$ ??
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ $\begin{aligned}[t]
          \stackapp \aStack {\subs {\aTerm} \env}
          &= \stackapp {\aStack'} {\subs {\aTerm[3]} \env} && \text{by \stepref{label-4.2}} \\
          &\rightsquigarrow^* \go {\scoped {\aTerm[3]} \env} {\aStack'} && \text{by \stepref{label-4.3}} \\
          &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-4.1}} \\
          &\not \rightsquigarrow && \text{by \stepref{label-4.3}}
        \end{aligned}$
    \end{proof}
  \end{proof}
  \step{label-5}{\case{$\aTerm = \ttyapp {\aTerm[3]} {\aType[2]}$ (line~\ref{go:typeApply})}}
  \begin{proof}
    \step{label-5.1}{$\go {\scoped {(\ttyapp {\aTerm[3]} {\aType[2]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aPolyFrameAll {\aType[2]} \env} \aStack)}}$}
    \step{label-5.2}{$\simplBeta[*] {\stackapp {(\nonEmptyStack {\aPolyFrameAll {\aType[2]} \env} \aStack)} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aPolyFrameAll {\aType[2]} \env} \aStack)}}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aPolyFrameAll {\aType[2]} \env} \aStack)}} {\aType[1]}$}
    \step{label-5.3}{$\stackapp \aStack {\subs {(\ttyapp {\aTerm[3]} {\aType[2]})} \env} = \stackapp {(\nonEmptyStack {\aPolyFrameAll {\aType[2]} \env} \aStack)} {\subs {\aTerm[3]} \env}$}
  \end{proof}
  \step{label-6}{\case{$\aTerm = \ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]}$ (line~\ref{go:ite})}}
  \begin{proof}
    \pflet{$\aStack' = \nonEmptyStack {\aIteFrameAll {\aTerm[4]} {\aTerm[5]} \env} \aStack$}
    \step{label-6.1}{$\go {\scoped {\aTerm} \env} \aStack = \go {\scoped {\aTerm[3]} \env {\aStack'}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-6.2}{$\simplBeta[*]{\stackapp \emptyStack {\subs {\aTerm[4]} \env}} {\betaNormal{\go {\scoped {\aTerm[4]} \env} \emptyStack}}$}
     \begin{proof}
      \step{label-1.1.2.1}{$\begin{conj}\judge \aContext {\subs {\aTerm[4]} {\env}} {\aType} \\ \frameJudge \aContext {\emptyStack} {\aType} {\aType} \end{conj}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-typed}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $(\emptyStack, \aTerm[4]) < (\aStack, \aTerm)$
      \end{proof}
    \end{proof}
    \step{label-6.3}{$\simplBeta[*]{\stackapp \emptyStack {\subs {\aTerm[5]} \env}} {\betaNormal{\go {\scoped {\aTerm[5]} \env} \emptyStack}}$}
     \step{label-6.4}{${\stackapp \aStack {\subs {\aTerm} \env}} = {\stackapp {\aStack'} {\subs {\aTerm[3]} \env}}$}
    \begin{proof}
      \pf\ By definition of $\_[\_]$
    \end{proof}
    \step{label-6.5}{$\simplBeta[*]{\stackapp {\aStack'} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env {\aStack'}}}$}}
    \begin{proof}
      \step{label-6.5.1}{$\begin{conj}\judge \aContext {\subs {\aTerm[3]} \env} \tyBool \\ \judge \aContext {\subs {\aTerm[4]} {\env}} {\aType} \\ \judge \aContext {\subs {\aTerm[5]} {\env}} {\aType} \end{conj}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-6.5.2}{$\aStack'$ is simplifiable}
      \begin{proof}
        \pf\ By \stepref{label-6.2} and \stepref{label-6.3}
      \end{proof}
      \step{label-6.5.3}{$\frameJudge \aContext {\aStack'} \tyBool {\aType[1]}$}
      \begin{proof}
        \pf\ By \stepref{label-6.5.1} and inversion of \ref{pf:stack-typed}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH on $(\aStack', \aTerm[3]) < (\aStack, \aTerm)$ ??
      \end{proof}
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ $\begin{aligned}[t]
          \stackapp \aStack {\subs {\aTerm} \env} &= {\stackapp {\aStack'} {\subs {\aTerm[3]} \env}} && \text{by \stepref{label-6.4}} \\
          &\rightsquigarrow^* \go {\scoped {\aTerm[3]} \env} {\aStack'} && \text{by \stepref{label-6.5}} \\
          &= \go {\scoped {\aTerm} \env} \aStack && \text{by \stepref{label-6.1}} \\
          &\not \rightsquigarrow && \text{by \stepref{label-6.5}}
        \end{aligned}$
    \end{proof}
  \end{proof}
  \step{label-7}{\case{$\aTerm = \tlet \aVar {\aTerm[3]} {\aTerm[4]}$ (line~\ref{go:let})}}
  \begin{proof}
    \step{label-7.1}{$\go {\scoped {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env} \aStack = \stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
    \step{label-7.2}{$\simplBeta[*] {\subs {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} {\betaNormal{\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}$ and $\judge {\ctxtExtend \aContext {\aVar[1]} {\aType[2]}} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack} \aType$}
    \step{label-7.3}{$\simplBeta[*] {\subs {\aTerm[3]} \env } {\betaNormal{\go {\scoped {\aTerm[3]} \env} \emptyStack}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\aType[2]}$}
    \step{label-7.4}{$\betaNormal{\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}}$}
    \step{label-7.5}{$\judge \aContext {\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}} {\aType[1]}$}
    \step{label-7.6}{$\simplBeta[*] {\stackapp \aStack {\subs {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env}} {\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}}$}
  \end{proof}
  \step{label-8}{\case{$\aTerm = \ttyann {\aTerm[3]} {\aType[2]}$ (line~\ref{go:annot})}}
  \begin{proof}
    \step{label-8.1}{$\go {\scoped {\ttyann {\aTerm[3]} {\aType[2]}} \env} \aStack = \go {\scoped {\aTerm[3]} \env} \aStack$}
    \step{label-8.2}{$\simplBeta[*] {\stackapp \aStack {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env} \aStack}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env} \aStack} {\aType[1]}$}
    \step{label-8.3}{$\simplBeta{\stackapp \aStack {\subs {\ttyann {\aTerm[3]} {\aType[2]}} \env}} {\stackapp \aStack {\subs {\aTerm[3]} \env}}$}
  \end{proof}
\end{proof}

\newgeometry{top=0.5cm}
\begin{figure}
  \ocamlfrom{stack.ml}{go}
\end{figure}
\restoregeometry

\subsection{Some problems with typing stacks}

We ran into problems while trying to typecheck stacks.

Here is one example: 
$$
\tapp {(\ttyapp {(\ttyfun \aTypeVar {(\tfun \aVar \aTypeVar
        {(\tapp {(\tapp {(\ttyapp { \square } {\aTypeVar[1]})} \aVar)} {\aVar[1]})})})}
        \tyBool)} \true
$$

After 2 rounds of simplification, we end up with the following stack, with $\env = \envextend {\envextend \envid \aTypeVar \tyBool} \aVar \true$.

\begin{mathpar}
\aRule
            {\aRule
              {\aRule
              { {\frameJudge
                 {\aContext}
                 {\emptyStack}
                 {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}
                 {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}  \\
                {\judge {\aContext} {\aVar[1]} {\aTypeVar[1]}}
              }
              {{\frameJudge 
                {\aContext}
                {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}
                {{\aTypeVar[1]} \to {\aType[2][{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
                {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}} \\
                {\judge {\aContext} {\aVar} {\aTypeVar}}
                }
              {}}
              {\frameJudge
              {\aContext}
              {\nonEmptyStack {\aFunFrameAll {\aVar} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}}
              {\aTypeVar \to {\aTypeVar[1]} \to {\aType[2][{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
              {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
              {}
            }
            {\frameJudge
              {\aContext = \hasType \aVar \aTypeVar, \hasType {\aVar[1]} {\aTypeVar[1]}}
              {\nonEmptyStack {\aPolyFrameAll {\aTypeVar[1]} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}}}
              {\forall {\aTypeVar[2]}, {\aTypeVar \to {\aTypeVar[2]} \to {\aType[2]}}}
              {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
            {}
\end{mathpar}
In the example above, if you keep $\aTypeVar \mapsto \tyBool$, but change $\aVar \mapsto 42$, the
resulting type is the same, but the stack shouldn't typecheck.
The problem is that we are not using substitutions while typechecking our stacks.

So we changed the rules to include the substitutions on the terms before checking them, and on the environement.

With those rules, we can accuratly typecheck the following example: \\
$$\ttyapp {(\ttyfun \aTypeVar {\ttyapp {(\ttyapp {(\ttyfun {\aTypeVar[1]} {\ttyapp {\square} {\aTypeVar[1]}})} \tyBool)} \aTypeVar})} {\mathbb{N}}$$

\begin{mathpar}
\aRule
  {\aRule
    {\frameJudge
      {\subs {\subs {\aContext} {\env[2]}} {\env[3]}}
      {\emptyStack}
      {{\subs {\aTypeVar} {\env[3]}} \times {\subs {\aTypeVar[1]} {\env[2]}}}
      {\mathbb{N} \times \tyBool}}
    {\frameJudge
      {\subs {\aContext} {{\env[2]}}}
      {\square \: \scoped {\aTypeVar} {{\env[3]} = \aTypeVar \mapsto \mathbb{N}} : \emptyStack}
      {\forall {\aType[3]} {{{\aType[3]} \times {\subs {\aTypeVar[1]} {\env[2]}}}}}
      {\mathbb{N} \times \tyBool}}
    {}}
  {\frameJudge
    {\aContext = \aTypeVar, {\aTypeVar[1]}}
    {{\square \: \scoped {\aTypeVar[1]} {{\env[2]} = \envid, \aTypeVar \mapsto \mathbb{N}, {\aTypeVar[1]} \mapsto \tyBool}} : {\square \: \scoped {\aTypeVar} {{\env[3]} = \aTypeVar \mapsto \mathbb{N}}} : \emptyStack}
    {\forall {\aType[2]} {\forall {\aType[3]} {{{\aType[3]} \times {\aType[2]}}}}}
    {\mathbb{N} \times \tyBool}}
  {}
\end{mathpar}


\subsection{Lemma A}
\begin{proof}
    \pflet
    {\begin{enumerate}
        \item $\aContext$ be a context
        \item $\aTerm$ and $\aTerm'$ be terms
        \item $\aType[1]$ be a type
    \end{enumerate}}
    \assume{
        \begin{enumerate}
        \item $\judge \aContext \aTerm {\aType[1]}$ \label{lA:H1}
        \item $\simplBeta \aTerm {\aTerm'}$ \label{lA:H2}
        \end{enumerate}}
    \prove{$\judge \aContext {\aTerm'} {\aType[1]}$}
    \pfsketch\ Proof by induction on $\simplBeta \aTerm {\aTerm'}$.
    \step{label-1}{\case{$\aRule   { }
                                    {\simplBeta {\tapp {(\tfun \aVar \aType {\aTerm[3]})} \aBase} {{\subs {\aTerm[3]} {\envextend \envid \aVar {\aBase}}}}}
                                    { }$}}
    \begin{proof}
        \step{label-1.1}{\begin{enumerate}
                        \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[3]} {\aType}$
                        \item $\judge \aContext \aBase {\aType[1]}$
                        \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} twice.
        \end{proof}
        \qedstep
        \begin{proof}
           \pf\ \aRule  {\text{by substitution lemma and {\stepref{label-1.1}}}}
                    {\judge {\aContext}
                            {\subs{\aTerm[3]}{\envextend \envid \aVar \aBase}}
                            {\aType}}
                    {}
        \end{proof}
    \end{proof}
    \step{label-2}{\case{$\aRule    { }
                                    {\simplBeta {\ttyapp {(\ttyfun \aTypeVar \aTerm)} {\aType[1]}} {{\subs \aTerm {\envextend \envid \aTypeVar {\aType[1]}}}}}
                                    { }$}}
    \begin{proof}
        \step{label-2.1}{$\judge {\ctxtExtend{\aContext}{\aTypeVar}{\aType[1]}} {\aTerm} {\aType}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} twice.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by substitution lemma and {\stepref{label-2.1}}}}
                        {\judge {\aContext}
                        {\subs{\aTerm}{\envextend \envid {\aTypeVar} {\aType[1]}}}
                        {\aType}}
                        {}
        \end{proof}
    \end{proof}
    \step{label-3}{\case{$\aRule    { }
                                    {\simplBeta {\ite \true {\aTerm[3]} {\aTerm[1]}} {\aTerm[3]}}
                                    { }$}}
    \begin{proof}
        \step{label-3.1}{$\judge {\aContext} {\aTerm[3]} {\aType}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-3.1}}}}
                        {\judge {\aContext}
                        {\aTerm[3]}
                        {\aType}}
                        {}
        \end{proof}
    \end{proof}
    \step{label-4}{\case{$\aRule    { }
                                    {\simplBeta {\ite \true {\aTerm[1]} {\aTerm[3]}} {\aTerm[3]}}
                                    { }$}}
    \begin{proof}
        \pf\ Same reasoning than \stepref{label-3}
    \end{proof}

    \step{label-5}{\case{$\aRule    {\simplBeta {\subs {\aTerm[3]} {\envextend \envid \aVar \aVar}} {\aTerm[1]}}
                                    {\simplBeta {\tfun \aVar {\aType[1]} {\aTerm[3]}} {\tfun \aVar {\aType[1]} {\aTerm[1]}}}
                                    {}$}}
    \begin{proof}
        \step{label-5.1}{\begin{enumerate}
            \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[1]} {\domToCod}$
            \item $\judge \aContext {\aVar} {\aType[1]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} and by hypothesis.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-5.1}}}}
                        {\judge {\aContext}
                            {\tfun \aVar {\aType[1]} {\aTerm[1]}}
                            {\domToCod}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-6}{\case{$\aRule    {\simplBeta {\aTerm[3]} {\aTerm[1]}}
                                    {\simplBeta {\tapp {\aTerm[3]} \aBase} \tapp {\aTerm[1]} \aBase}
                                    {}$}}
    \begin{proof}
        \step{label-6.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\domToCod}$
            \item $\judge \aContext {\aBase} {\aType[1]}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1} twice.
        \end{proof}
        \step{label-6.2}{$\judge {\aContext} {\aTerm[1]} {\domToCod}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[1]}} \prec {\simplBeta{\tapp {\aTerm[3]} \aBase}{\tapp {\aTerm[1]} \aBase}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-6.2}}}} {\judge {\aContext} {\aTerm[1]} {\domToCod}} {} \\
                        \aRule {\text{by {\stepref{label-6.1}}}} {\judge \aContext \aBase {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\tapp {\aTerm[1]} \aBase}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-7}{\case{$\aRule    {\simplBeta {\aTerm[3]} {\aTerm[3]}'}
                                    {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {{\aTerm[3]}'}} {\aTerm[1]}}
                                    {}$}}
    \begin{proof}
        \step{label-7.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\aType[1]}$
            \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[1]} {\aType}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-7.2}{$\judge {\aContext} {\aTerm[3]'} {\aType[1]}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[3]'}} \prec {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {{\aTerm[3]}'}} {\aTerm[1]}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-7.2}}}} {\judge {\aContext} {\aTerm[3]'} {\aType[1]}} {} \\
                        \aRule {\text{by {\stepref{label-7.1}}}} {\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[1]} {\aType}} {}}
                        {\judge {\aContext}
                            {\tlet \aVar {{\aTerm[3]}'}}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-8}{\case{$\aRule    {\simplBeta {\subs {\aTerm[1]} {\envextend \envid \aVar \aVar}} {\aTerm[1]'}}
                                    {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet \aVar \aTerm \aTerm[1]'}}
                                    {}$}}
    \begin{proof}
        \step{label-8.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\aType[1]}$
            \item $\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[1]} {\aType}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-8.2}{$\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[1]'} {\aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[1]}{\aTerm[1]'}} \prec {\simplBeta {\tlet \aVar {\aTerm[3]} {\aTerm[1]}} {\tlet \aVar {\aTerm[3]}} {\aTerm[1]'}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-8.1}}}} {\judge {\aContext} {\aTerm[3]} {\aType[1]}} {} \\
                        \aRule {\text{by {\stepref{label-8.2}}}} {\judge {\ctxtExtend{\aContext}{\aVar}{\aType[1]}} {\aTerm[1]'} {\aType}} {}}
                        {\judge {\aContext}
                            {\tlet \aVar {\aTerm[3]} {\aTerm[1]'}}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

  \step{label-9}{\case{$\aRule  {\simplBeta {\aTerm[3]} {\aTerm[3]'}}
                                {\simplBeta {\ite {\aTerm[3]} {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm[3]'} {\aTerm[1]} {\aTerm[2]}}}
                                {}$}}
    \begin{proof}
        \step{label-9.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\tyBool}$
            \item $\judge {\aContext} {\aTerm[1]} {\aType}$
            \item $\judge {\aContext} {\aTerm[2]} {\aType}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-9.2}{$\judge {\aContext} {\aTerm[3]'} {\tyBool}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[3]'}} \prec {\simplBeta {\ite {\aTerm[3]} {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm[3]'} {\aTerm[1]} {\aTerm[2]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-9.2}}}} {\judge {\aContext} {\aTerm[3]'} {\tyBool}} {} \\
                        \aRule {\text{by {\stepref{label-9.1}}}} {\judge {\aContext} {\aTerm[1]} {\aType}} {} \\
                        \aRule {\text{by {\stepref{label-9.1}}}} {\judge {\aContext} {\aTerm[2]} {\aType}} {}}
                        {\judge {\aContext}
                            {\ite {\aTerm[3]'} {\aTerm[1]} {\aTerm[2]}}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-10}{\case{$\aRule   {\simplBeta {\aTerm[1]} {\aTerm[1]'}}
                                    {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]'} {\aTerm[2]} }}
                                    {} $}}
    \begin{proof}
        \step{label-10.1}{\begin{enumerate}
            \item $\judge {\aContext} {\aTerm[3]} {\tyBool}$
            \item $\judge {\aContext} {\aTerm[1]} {\aType}$
            \item $\judge {\aContext} {\aTerm[2]} {\aType}$
            \end{enumerate}}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-10.2}{$\judge {\aContext} {\aTerm[1]'} {\aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[1]}{\aTerm[1]'}} \prec {\simplBeta {\ite {\aTerm[3]} {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm[3]} {\aTerm[1]'} {\aTerm[2]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-10.1}}}} {\judge {\aContext} {\aTerm[3]} {\tyBool}} {} \\
                        \aRule {\text{by {\stepref{label-10.2}}}} {\judge {\aContext} {\aTerm[1]'} {\aType}} {} \\
                        \aRule {\text{by {\stepref{label-10.1}}}} {\judge {\aContext} {\aTerm[2]} {\aType}} {}}
                        {\judge {\aContext}
                            {\ite {\aTerm[3]} {\aTerm[1]'} {\aTerm[2]}}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-11}{\case{$\aRule   {\simplBeta {\aTerm[2]} {\aTerm[2]'}}
                                    {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]} {\aTerm[2]'} }}
                                    {} $}}
    \begin{proof}
        \pf\ same reasoning than \stepref{label-10}
    \end{proof}


    \step{label-12}{\case{$\aRule   {\simplBeta {\subs {\aTerm[3]} {\envextend \envid \aTypeVar \aTypeVar}} {\aTerm[1]}}
                                    {\simplBeta {\ttyfun \aTypeVar {\aTerm[3]}} {\ttyfun \aTypeVar {\aTerm[1]}}}
                                    {}$}}
    \begin{proof}
        \step{label-12.1}{$\judge {\aContext} {\aTerm[3]} {\aType}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-12.2}{$\judge {\aContext, \aTypeVar} {\aTerm[1]} {\aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[1]}} \prec {\simplBeta {\ttyfun \aTypeVar {\aTerm[3]}} {\ttyfun \aTypeVar {\aTerm[1]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-12.2}}}} {\judge {\aContext, \aTypeVar } {\aTerm[1]} {\aType}} {}}
                        {\judge {\aContext}
                            {\ttyfun \aTypeVar {\aTerm[1]}}
                            {\tforall \aTypeVar \aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-13}{\case{$\aRule   {\simplBeta {\aTerm[3]} {\aTerm[1]}}
                                    {\simplBeta {\ttyapp {\aTerm[3]} {\aType[1]}} {\ttyapp {\aTerm[1]} {\aType[1]}}}
                                    {}$}}
    \begin{proof}
        \step{label-13.1}{$\judge {\aContext} {\aTerm[3]} {\aType}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \step{label-13.2}{$\judge {\aContext} {\aTerm[1]} {\aType}$}
        \begin{proof}
            \pf\ by IH on ${\simplBeta{\aTerm[3]}{\aTerm[1]}} \prec {\simplBeta {\ttyapp {\aTerm[3]} {\aType[1]}} {\ttyapp {\aTerm[1]} {\aType[1]}}}$
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-13.2}}}} {\judge {\aContext} {\aTerm[1]} {\aType}} {}}
                        {\judge {\aContext}
                            {\ttyapp {\aTerm[1]} {\aType[1]}}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-14}{\case{$\aRule   { }
                                    {\simplBeta {\ttyann {\aTerm[3]} \aType} {\aTerm[3]}}
                                    {}$}}
    \begin{proof}
        \step{label-14.1}{$\judge {\aContext} {\aTerm[3]} {\aType}$}
        \begin{proof}
            \pf\ By inversion of \ref{lA:H1}.
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-14.1}}}}
                        {\judge {\aContext}
                            {\aTerm[3]}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}
\end{proof}

\subsection{Lemma B}
\begin{proof}
    \assume{
        \begin{enumerate}
        \item $\judge \aContext \aTerm {\aType}$ \label{lB:H1}
        \item $\frameJudge{\aContext}{\aStack}{\aType}{\aType[1]}$ \label{lB:H2}
        \end{enumerate}}
    \prove{$\judge \aContext {\stackapp \aStack \aTerm} {\aType[1]}$}
    \pfsketch\ Proof by induction on $\frameJudge{\aContext}{\aStack}{\aType}{\aType[1]}$.
    \step{label-1}{\case{$\aRule    { }
                                    {\frameJudge \aContext \emptyStack \aType {\aType}}
                                    {}$}}
    \begin{proof}
        \step{label-1.1}{$\judge \aContext \aTerm \aType$}
        \begin{proof}
            \pf\ by case analysis and \ref{lB:H1}.
        \end{proof}
        \step{label-1.2}{$\stackapp{\emptyStack}{\aTerm} = \aTerm$}
        \begin{proof}
            \pf\ by definition of \ref{stack-application}
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ \aRule {\text{by {\stepref{label-1.1}}} \\
                        \text{by {\stepref{label-1.2}}}}
                        {\judge {\aContext}
                            {\stackapp{\emptyStack}{\aTerm}}
                            {\aType}}
                        {}
        \end{proof}
    \end{proof}

    \step{label-2}{\case{$\aRule    {\frameJudge \aContext {\aStack'} \aType {\aType[2]} \\
                                    \judgecheck \aContext {\aType[1]} {\subs \aBase \env}}
                                    {\frameJudge \aContext {(\nonEmptyStack \aFunFrame {\aStack'})} \domToCod {\aType[2]}}
                                    {}$}}
    \begin{proof}
        \step{label-2.1}{$\judge \aContext \aTerm \domToCod$}
        \begin{proof}
            \pf\ by case analysis.
        \end{proof}
        \step{label-2.2}{$\stackapp{\aStack}{\aTerm} = \stackapp{\aStack'}{\tapp{\aTerm}{\subs \aBase \env}} $}
        \begin{proof}
            \pf\ by definition of \ref{stack-application}
        \end{proof}
        \step{label-2.3}{$\judge{\aContext}{\tapp{\aTerm}{\subs \aBase \env}}{\aType} $}
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-2.1}}}} {\judge \aContext \aTerm \domToCod} {} \\
                        \aRule {\text{by {\stepref{label-2.2}}}} {\judge \aContext {\subs \aBase \env} {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\tapp{\aTerm}{\subs \aBase \env}}
                            {\aType}}
                        {}
        \end{proof}
        \step{label-2.4}{$\frameJudge{\aContext}{\aStack'}{\aType}{\aType[2]} $}
        \begin{proof}
            \pf\ by \ref{lB:H2}
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ by IH on  ${\frameJudge{\aContext}{\aStack'}{\aType}{\aType[2]}} \prec {\frameJudge{\aContext}{\aStack}{\domToCod}{\aType[2]}}$ and \stepref{label-2.3}.
        \end{proof}
    \end{proof}

    \step{label-3}{\case{$\aRule    {\frameJudge \aContext {\aStack'} {\subs \aType {\envextend \envid \aTypeVar {\subs {\aType[1]} \env}}} {\aType[2]}}
                                    {\frameJudge \aContext {(\nonEmptyStack \aPolyFrame {\aStack'})} {\tforall \aTypeVar \aType} {\aType[2]}}
                                    {}$}}
    \begin{proof}
        \step{label-3.1}{$\judge \aContext \aTerm {\tforall \aTypeVar \aType}$}
        \begin{proof}
            \pf\ by case analysis.
        \end{proof}
        \step{label-3.2}{$\stackapp{\aStack}{\aTerm} = \stackapp{\aStack'}{\ttyapp{\aTerm}{\subs {\aType[1]} \env}} $}
        \begin{proof}
            \pf\ by definition of \ref{stack-application}
        \end{proof}
        \step{label-3.3}{$\judge{\aContext}{\tapp{\aTerm}{\subs {\aType[1]} \env}}{\aType} $}
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-3.1}}}} {\judge \aContext \aTerm {\tforall \aTypeVar \aType}} {} \\
                        \aRule {\text{by {\stepref{label-3.2}}}} {\judge \aContext {\subs {\aType[1]} \env} {\aType[1]}} {}}
                        {\judge {\aContext}
                            {\tapp{\aTerm}{\subs {\aType[1]} \env}}
                            {\aType}}
                        {}
        \end{proof}
        \step{label-3.4}{$\frameJudge{\aContext}{\aStack'}{\aType}{\aType[2]} $}
        \begin{proof}
            \pf\ by \ref{lB:H2}
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ by IH on  ${\frameJudge{\aContext}{\aStack'}{\aType}{\aType[2]}} \prec {\frameJudge{\aContext}{\aStack}{\tforall \aTypeVar \aType}{\aType[2]}}$ and \stepref{label-3.3}.
        \end{proof}
    \end{proof}

    \step{label-4}{\case{$\aRule    {\judge \aContext {\subs {\aTerm[1]} \env} {\aType[2]} \\
                                    \judge \aContext {\subs {\aTerm[2]} \env} {\aType[2]} \\
                                    \frameJudge \aContext {\aStack'} {\aType[2]} {\aType}}
                                    {\frameJudge \aContext {(\nonEmptyStack \aIteFrame {\aStack'})} \tyBool \aType}
                                    {}$}}
    \begin{proof}
        \step{label-4.1}{$\judge \aContext \aTerm \tyBool$}
        \begin{proof}
            \pf\ by case analysis.
        \end{proof}
        \step{label-4.2}{$\stackapp{\aStack}{\aTerm} = \stackapp{\aStack'}{\ite{\aTerm}{\subs {\aTerm[1]} \env}{\subs {\aTerm[2]} \env}} $}
        \begin{proof}
            \pf\ by definition of \ref{stack-application}
        \end{proof}
        \step{label-4.3}{$\judge{\aContext}{\ite{\aTerm}{\subs {\aTerm[1]} \env}{\subs {\aTerm[2]} \env}}{\aType} $}
        \begin{proof}
            \pf\ \aRule {\aRule {\text{by {\stepref{label-4.1}}}} {\judge \aContext \aTerm \tyBool} {} \\
                        \aRule {\text{by {\stepref{label-4.2}}}} {\judge \aContext {\subs {\aTerm[1]} \env} \aType} {} \\
                        \aRule {\text{by {\stepref{label-4.2}}}} {\judge \aContext {\subs {\aTerm[2]} \env} \aType} {}}
                        {\judge {\aContext}
                            {\ite{\aTerm}{\subs {\aTerm[1]} \env}{\subs {\aTerm[2]} \env}}
                            {\aType}}
                        {}
        \end{proof}
        \step{label-4.4}{$\frameJudge{\aContext}{\aStack'}{\aType}{\aType[2]} $}
        \begin{proof}
            \pf\ by \ref{lB:H2}
        \end{proof}
        \qedstep
        \begin{proof}
            \pf\ by IH on  ${\frameJudge{\aContext}{\aStack'}{\aType}{\aType[2]}} \prec {\frameJudge{\aContext}{\aStack}{\tyBool}{\aType[2]}}$ and \stepref{label-4.3}.
        \end{proof}
    \end{proof}
\end{proof}

\end{document}