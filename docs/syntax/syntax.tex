\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{pf}
\usepackage{plong}
\usepackage{listings-ocaml}
\usepackage{xcolor}
\usepackage{hyperref}
\newcommand{\TODO}[1]{\textcolor{red}{$\langle$ Pierre:}~#1\textcolor{red}{~$\rangle$}}

\begin{document}
\section{Syntax}
\subsection{Terms}
$
\begin{array}{ccll}
\aTerm, \aTerm[1], \aTerm[2] & ::= & & \\
& | & \aBase & \text{(base)} \\
& | & \tfun \aVar \aType \aTerm & \text{(abstraction)} \\
& | & \tapp \aTerm \aBase & \text{(function application)} \\
& | & \tlet \aVar \aTerm {\aTerm[1]} & \text{(let binding)} \\
& | & \ite \aTerm {\aTerm[1]} {\aTerm[2]} & \text{(conditionnal)}\\
& | & \ttyfun \aTypeVar \aTerm & \text{(type abstraction)} \\
& | & \ttyapp \aTerm \aType & \text{(type application)} \\
& | & \ttyann \aTerm \aType & \text{(type annotation)}
\end{array}
$\\
$
\begin{array}{ccll}
\aBase & ::= & & \\
& | & \aVar & \text{(variable)} \\
& | & \true & \text{(true)} \\
& | & \false & \text{(false)} \\
\end{array}
$
\subsection{Types}
$
\begin{array}{ccll}
\aType, \aType[1] & ::= & & \\
& | & \aTypeVar & \text{(type variable)} \\
& | & \tyBool & \text{(bool type)} \\
& | & \aDomType \to \aCodType & \text{(function type)} \\
& | & \tforall \aTypeVar \aType & \text{(polymorphic type)} \\
& | & \aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k} & \text{(tuples)}
\end{array}
$
\section{Free variables}
\subsection{Free type variables in type}
\begin{align*}
FV(\aTypeVar) &= \aTypeVar \\
FV(\tyBool) &= \emptyset \\
FV(\domToCod) &= FV(\aDomType) \cup FV(\aCodType) \\
FV(\tforall \aTypeVar \aType) &= FV(\aType) \setminus \{ \aTypeVar \} \\
FV(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k}) &= FV(\aType[2]) \cup FV(\aType[3]) \cup \ldots \cup FV(\aType_{k}) \\
\end{align*}
\subsection{Free variables in term}
\begin{align*}
FV(\aVar) &= \aVar \\
FV(\true) &= \emptyset \\
FV(\false) &= \emptyset \\
FV(\tfun \aVar \aType \aTerm) &= FV(\aType) \cup (FV(\aTerm) \setminus \{ \aVar \}) \\
FV(\tapp \aTerm \aBase) &= FV(\aTerm) \cup FV(\aBase) \\
FV(\tlet \aVar \aTerm {\aTerm[1]}) &= FV(\aTerm) \cup (FV(\aTerm[1]) \setminus \{\aVar\}) \\
FV(\ite \aTerm {\aTerm[1]} {\aTerm[2]}) &= FV(\aTerm) \cup FV(\aTerm[1]) \cup FV(\aTerm[2]) \\
FV(\ttyfun \aTypeVar \aTerm) &= FV(\aTerm) \setminus \{ \aTypeVar \} \\
FV(\ttyapp \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
FV(\ttyann \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
\end{align*}
\section{Scoped terms}
\subsection{Terms environnement}
$
\begin{array}{ccll}
\env & ::= & \\
& | & \envid & \text{(identity)}\\
& | & \envextend \rho \aVar \aBase & \text{(variable)} \\
& | & \envextend \rho \aTypeVar \aType & \text{(type variable)}
\end{array}
$\\
A scoped term is written $\scoped \aTerm \env$ and a scoped type is written $\scoped \aType \env$

\subsection{Well scoped} \label{well-scoped-term}
$\scoped \aTerm \env$ is well-scoped if:
\begin{itemize}
  \item the sets of type variables and variables are disjoint
  \item the domains of the type substitution and the variable substitutions are disjoint
  \item the co-domain of the substitution is included in the corresponding set
  (for both substitutions)
\end{itemize}
$\scoped \aTerm \env$ is well scoped if the free variables and the free type variables of $\aTerm$ are substituted by $\env$ \\
$\scoped \aType \env$ is well scoped if the free type variables of $\aType$ are substituted by $\env$
\subsection{Substitution} \label{substitution}
\subsubsection{Type substitution}

\begin{align*}
\subs \aTypeVar \envid &= \aTypeVar \\
\subs \aTypeVar {\envextend \env \aVar \aBase} &= \subs \aTypeVar \rho \\
\subs \aTypeVar {\envextend \env {\aTypeVar[1]} \aType} &=
\begin{cases}
  \aType & \text{if } \aTypeVar = \aTypeVar[1] \\
  \subs \aTypeVar \env & \text{otherwise} \\
\end{cases} \\
\subs \tyBool \env &= \tyBool \\
\subs {(\aDomType \to \aCodType)} \env &= \subs \aDomType \env \to \subs \aCodType \env \\
\subs {(\tforall \aTypeVar \aType)} \env &= \tforall {\aTypeVar[1]} {\subs \aType {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\tforall \aTypeVar \aType) \text{ and } \aTypeVar[1] \notin FV(\env) \\
\subs {(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k})} \env &= \subs {\aType[2]} \env \tprod \subs {\aType[3]} \env \tprod \ldots \subs {\tprod \aType_{k}} \env
\end{align*}


\subsubsection{Term substitution}
\begin{align*}
\subs \aVar \envid &= \aVar \\
\subs \aVar {\envextend \env {\aVar[1]} \aBase} &=
\begin{cases}
  \aBase & \text{if } \aVar = \aVar[1] \\
  \subs \aVar \env & \text{otherwise}
\end{cases} \\
\subs \aVar {\envextend \env \aTypeVar \aType} &= \subs \aVar \env \\
\subs \true \env &= \true \\
\subs \false \env &= \false \\
\subs {(\tfun \aVar \aType \aTerm)} \env &= \tfun {\aVar[1]} {\subs \aType \env} {\subs \aTerm {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tfun \aVar \aType \aTerm) \text{ and } \aVar[1] \notin FV(\env) \\
\subs {(\tapp \aTerm {\aTerm[1]})} \env &= \tapp {\subs \aTerm \env} {\subs {\aTerm[1]} \env} \\
\subs {(\tlet \aVar \aTerm \aTerm[1])} \env &= \tlet {\aVar[1]} {\subs \aTerm \env} {\subs {\aTerm[1]} {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tlet \aVar \aTerm \aTerm[1]) \text{ and } \aVar[1] \notin FV(\env) \\
\subs {(\ite \aTerm {\aTerm[1]} {\aTerm[2]})} \env &= \ite {\subs \aTerm \env} {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env} \\
\subs {(\ttyfun \aTypeVar \aTerm)} \env &= \ttyfun {\aTypeVar[1]} {\subs \aTerm {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm) \text{ and } \aTypeVar[1] \notin FV(\env) \\
\subs {(\ttyapp \aTerm \aType)} \env &= \ttyapp {\subs \aTerm \env} {\subs \aType \env} \\
\subs {\ttyann \aTerm \aType} \env &= \ttyann {\subs \aTerm \env} {\subs \aType \env}
\end{align*}
\section{Frames and stacks}
$
\begin{array}{ccll}
\aFrame & ::= & \\
& | & \aFunFrame & \text{(applied function)} \\
& | & \aPolyFrame & \text{(instantiated polymorphism)} \\
& | & \aIteFrame & \text{(if then else)}
\end{array}
$
\newline
\newline
$
\aStack ::= \emptyStack \:|\: \nonEmptyStack \aFrame \aStack \quad \text{(stacks)}
$
\subsection{Stack evaluation} \label{stack-evaluation}
\begin{align*}
  \stackapp \emptyStack \aTerm &= \aTerm \\
  \stackapp {(\nonEmptyStack \aFunFrame \aStack)} \aTerm &= \stackapp \aStack {\tapp \aTerm \aBase} \\
  \stackapp {(\nonEmptyStack \aPolyFrame \aStack)} \aTerm &= \stackapp \aStack {\ttyapp \aTerm {\aType[1]}} \\
  \stackapp {(\nonEmptyStack \aIteFrame \aStack)} \aTerm &= \stackapp \aStack {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} \\
\end{align*}

\section{Simplifications}
\subsection{Beta-reduction}
\begin{mathpar}
\aRule   { }
         {\tapp {(\tfun \aVar \aType \aTerm)} \aBase \rightsquigarrow \subs \aTerm {\envextend \envid \aVar \aBase}}
         {}

\aRule   { }
         {\ttyapp {(\ttyfun \aTypeVar \aTerm)} \aType \rightsquigarrow \subs \aTerm {\envextend \envid \aTypeVar \aType}}
         {}

\aRule   { }
         {\ite \true \aTerm {\aTerm[1]} \rightsquigarrow \aTerm}
         {}

\aRule   { }
         {\ite \false \aTerm {\aTerm[1]} \rightsquigarrow {\aTerm[1]}}
         {}

\aRule   {{\subs \aTerm {\envextend \envid \aVar {\aVar[1]}}} \rightsquigarrow {\aTerm[1]} \\
          \aVar[1] \notin FV(\tfun \aVar \aType \aTerm)}
         {\tfun \aVar \aType \aTerm \rightsquigarrow \tfun {\aVar[1]} \aType {\aTerm[1]}}
         {}

\aRule   {\aTerm \rightsquigarrow \aTerm[1]}
         {\tapp \aTerm \aBase \rightsquigarrow \tapp {\aTerm[1]} \aBase}
         {}

\aRule   {{\subs \aTerm {\envextend \envid \aVar {\aVar[1]}}} \rightsquigarrow \aTerm' \\
          \aTerm[1] \rightsquigarrow \aTerm[1]' \\
          \aVar[1] \notin FV(\tlet \aVar \aTerm {\aTerm[1]})}
         {\tlet \aVar \aTerm {\aTerm[1]} \rightsquigarrow \tlet {\aVar[1]} {\aTerm'} {\aTerm[1]'}}
         {}

\aRule   {\aTerm \rightsquigarrow \aTerm' \\
          \aTerm[1] \rightsquigarrow \aTerm[1]' \\
          \aTerm[2] \rightsquigarrow \aTerm[2]'}
         {\ite \aTerm {\aTerm[1]} {\aTerm[2]} \rightsquigarrow \ite {\aTerm'} {\aTerm[1]'} {\aTerm[2]'}}
         {}

\aRule   {{\subs \aTerm {\envextend \envid \aTypeVar {\aTypeVar[1]}}} \rightsquigarrow {\aTerm[1]} \\
          \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm)}
         {\ttyfun \aTypeVar \aTerm \rightsquigarrow \ttyfun {\aTypeVar[1]} {\aTerm[1]}}
         {}

\aRule   {\aTerm \rightsquigarrow \aTerm[1]}
         {\ttyapp \aTerm \aType \rightsquigarrow \ttyapp {\aTerm[1]} \aType}
         {}

\aRule   { }
         {\ttyann \aTerm \aType \rightsquigarrow \aTerm}
         {}

\end{mathpar}
\subsection{Correctness}
\begin{proof}
  \pfsketch\ Proof by induction on $\aTerm$
  \assume{\begin{pfenum}
            \item $\scoped \aTerm \env$ is a well-scoped term \label{pf:term-scoped}
            \item $\aStack$ is a well-scoped stack \label{pf:stack-scoped}
          \end{pfenum}}
  \prove{$\stackapp \aStack {\subs \aTerm \env} \to^* \go {\scoped \aTerm \env} \aStack$ where $\go {\scoped \aTerm \env} \aStack \not\to$}
  \step{label-1}{\case{$\aTerm = \aBase$ (line~\ref{go:base})}}
  \begin{proof}
    \step{label-1.1}{If $\subs \aBase \env = \true$ and $\aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'}$}
    \begin{proof}
      \step{label-1.1.1}{$\stackapp {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} \true \to \stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}$}
      \begin{proof}
        \pf\ By definition of stack evaluation and $\to$
      \end{proof}
      \step{label-1.1.2}{$\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}} \to^* \go {\scoped {\aTerm[1]} {\env'}} {\aStack'} \not\to$}
      \begin{proof}
        \pf\ By ?
      \end{proof}
      \step{label-1.1.3}{$\go {\scoped \aBase \env} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} = \go {\scoped {\aTerm[1]} {\env'}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
    \end{proof}
    \step{label-1.2}{If $\subs \aBase \env = \false$ and $\aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'}$}
    \begin{proof}
      \step{label-1.2.1}{$\stackapp {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} \false \to \stackapp {\aStack'} {\subs {\aTerm[2]} {\env'}}$}
      \begin{proof}
        \pf\ By definition of stack evaluation and $\to$
      \end{proof}
      \step{label-1.2.2}{$\stackapp {\aStack'} {\subs {\aTerm[2]} {\env'}} \to^* \go {\scoped {\aTerm[2]} {\env'}} {\aStack'} \not\to$}
      \begin{proof}
        \pf\ By ?
      \end{proof}
      \step{label-1.2.3}{$\go {\scoped \aBase \env} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} = \go {\scoped {\aTerm[2]} {\env'}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
    \end{proof}
    \step{label-1.3}{Else}
    \begin{proof}
      \step{label-1.3.1}{$\stackapp \aStack {\subs \aBase \env} \not\to$}
      \begin{proof}
        \pf\ By definition of stack evaluation and $\to$
      \end{proof}
      \step{label-1.3.2}{$\go {\scoped \aBase \env} \aStack = \stackapp \aStack {\subs \aBase \env}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-2}{\case{\begin{pfenum}
                        \item $\aTerm = (\tfun \aVar \aType {\aTerm[3]})$ \label{pf:2-term}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[3]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[3]} {\env[1]}} \to^* \go {\scoped {\aTerm[3]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:2-ih}
                      \end{pfenum}}}
  \begin{proof}
    \step{label-2.1}{If $\aStack = \nonEmptyStack {\aFunFrame[\env']} {\aStack'}$ (line~\ref{go:fun-holefun})}
    \begin{proof}
      \step{label-2.1.1}{$\stackapp {(\nonEmptyStack {\aFunFrame[\env']} {\aStack'})} {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env} \to \stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar {\subs \aBase {\env'}}}}$}
      \begin{proof}
        \pf\ \\
        $\begin{aligned}[t]
          & \stackapp {(\nonEmptyStack {\aFunFrame[\env']} {\aStack'})} {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env} \\
          & = \stackapp {\aStack'} {\tapp {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env} {(\subs \aBase {\env'})}} \\
          & = \stackapp {\aStack'} {\tapp {(\tfun {\aVar[1]} {\subs \aType \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} {(\subs \aBase {\env'})}} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env) \\
          & \to \stackapp {\aStack'} {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} {\subs \aBase {\env'}}}} \\
          & = \stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar {\subs \aBase {\env'}}}} \text{ as } \aVar[1] \notin FV(\env)
        \end{aligned}$
      \end{proof}
      \step{label-2.1.2}{$\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar {\subs \aBase {\env'}}}} \to^* \go {\scoped {\aTerm[3]} {\envextend \env \aVar {\subs \aBase {\env'}}}} {\aStack'} \not\to$}
      \begin{proof}
        \step{label-2.1.2.1}{$\scoped {\aTerm[3]} {\envextend \env \aVar {\subs \aBase {\env'}}}$ is well scoped}
        \begin{proof}
          \step{label-2.1.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm) \cup \{ x \}$}
          \begin{proof}
            \pf\ By \stepref{label-2}:\ref{pf:2-term} and the definition of free variables
          \end{proof}
          \qedstep
          \begin{proof}
            \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
          \end{proof}
        \end{proof}
        \step{label-2.1.2.2}{$\aStack'$ is well scoped}
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:stack-scoped} and the definition of well scoped stack~\ref{well-scoped-stack}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \stepref{label-2}:\ref{pf:2-ih}
        \end{proof}
      \end{proof}
      \step{label-2.1.3}{$\go {\scoped {(\tfun \aVar \aType {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aVar {\subs \aBase {\env'}}}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
    \end{proof}
    \step{label-2.2}{Else (line~\ref{go:fun-else})}
    \begin{proof}
      \step{label-2.2.1}{$\stackapp \aStack {\subs {(\tfun \aVar \aType {\aTerm[3]})} \env} \to^* \stackapp \aStack {\tfun {\aVar[1]} {\subs \aType \env} {\aTerm[2]}}$ where $\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}} \to^* \aTerm[2]$}
      \begin{proof}
        \pf\ By substitution~\ref{substitution} and d√©finition of $\to^*$
      \end{proof}
      \step{label-2.2.2}{$\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}} \to^* \go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack \not\to$}
      \begin{proof}
        \step{label-2.2.2.1}{$\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}$ is well scoped}
        \begin{proof}
          \step{label-2.2.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm) \cup \{ x \}$}
          \begin{proof}
            \pf\ By \stepref{label-2}:\ref{pf:2-term} and the definition of free variables
          \end{proof}
          \qedstep
          \begin{proof}
            \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
          \end{proof}
        \end{proof}
        \step{label-2.2.2.2}{$\emptyStack$ is well scoped}
        \begin{proof}
          \pf\ By the definition of well scoped stack~\ref{well-scoped-stack}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \stepref{label-2}:\ref{pf:2-ih}
        \end{proof}
      \end{proof}
      \step{label-2.2.3}{$\go {\scoped {(\tfun \aVar \aType {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\tfun {\aVar[1]} {\subs \aType \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-3}{\case{\begin{pfenum}
                        \item $\aTerm = \ttyfun \aTypeVar {\aTerm[3]}$ \label{pf:3-term}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[3]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[3]} {\env[1]}} \to^* \go {\scoped {\aTerm[3]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:3-ih}
                       \end{pfenum}}}
  \begin{proof}
    \step{label-3.1}{If $\aStack = \nonEmptyStack {\aPolyFrame[\env']} {\aStack'}$ (line~\ref{go:tyfun-holetype})}
    \begin{proof}
      \step{label-3.1.1}{$\stackapp {(\nonEmptyStack {\aPolyFrame[\env']} {\aStack'})} {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \to \stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\subs {\aType[1]} {\env'}}}}$}
      \step{label-3.1.2}{$\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\subs {\aType[1]} {\env'}}}} \to^* \go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\subs {\aType[1]} {\env'}}}} {\aStack'} \not\to$}
      \step{label-3.1.3}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\subs {\aType[1]} {\env'}}}} {\aStack'}$}
    \end{proof}
    \step{label-3.2}{Else (line~\ref{go:tyfun-else})}
    \begin{proof}
      \step{label-3.2.1}{$\stackapp \aStack {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \to^* \stackapp \aStack {\ttyfun {\aTypeVar[1]} {\aTerm[2]}}$ where $\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}} \to^* \aTerm[2]$}
      \step{label-3.2.2}{$\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}} \to^* \go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack \not\to $}
      \step{label-3.2.3}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$}
    \end{proof}
  \end{proof}
  \step{label-4}{\case{\begin{pfenum}
                        \item $\aTerm = \tapp {\aTerm[3]} {\aBase}$ (line~\ref{go:funApply}) \label{pf:4-term}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[3]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[3]} {\env[1]}} \to^* \go {\scoped {\aTerm[3]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:4-ih}
                      \end{pfenum}}}
  \begin{proof}
    \step{label-4.1}{$\stackapp \aStack {\subs {(\tapp {\aTerm[3]} {\aBase})} \env} = \stackapp {(\nonEmptyStack \aFunFrame \aStack)} {\subs {\aTerm[3]} \env}$}
    \begin{proof}
      \pf\ By substitution~\ref{substitution} and stack evaluation~\ref{stack-evaluation}
    \end{proof}
    \step{label-4.2}{$\stackapp {(\nonEmptyStack \aFunFrame \aStack)} {\subs {\aTerm[3]} \env} \to^* \go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack \aFunFrame \aStack)} \not\to$}
    \begin{proof}
      \step{label-4.2.1}{$\scoped {\aTerm[3]} \env$ and $\scoped \aBase \env$ are well scoped}
      \begin{proof}
        \step{label-4.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm)$ and $FV(\aBase) \subseteq FV(\aTerm)$}
        \begin{proof}
          \pf\ By \stepref{label-4}:\ref{pf:4-term} and the definition of free variables
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
        \end{proof}
      \end{proof}
      \step{label-4.2.2}{$(\nonEmptyStack \aFunFrame \aStack)$ is well scoped}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-scoped} and the definition of well scoped stack~\ref{well-scoped-stack}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By \stepref{label-4}:\ref{pf:4-ih}
      \end{proof}
    \end{proof}
    \step{label-4.3}{$\go {\scoped {(\tapp {\aTerm[3]} \aBase)} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack \aFunFrame \aStack)}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
  \end{proof}
  \step{label-5}{\case{\begin{pfenum}
                        \item $\aTerm = \ttyapp {\aTerm[3]} {\aType[1]}$ (line~\ref{go:typeApply}) \label{pf:5-term}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[3]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[3]} {\env[1]}} \to^* \go {\scoped {\aTerm[3]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:5-ih}
                      \end{pfenum}}}
  \begin{proof}
    \step{label-5.1}{$\stackapp \aStack {\subs {(\ttyapp {\aTerm[3]} {\aType[1]})} \env} = \stackapp {(\nonEmptyStack \aPolyFrame \aStack)} {\subs {\aTerm[3]} \env}$}
    \step{label-5.2}{$\stackapp {(\nonEmptyStack \aPolyFrame \aStack)} {\subs {\aTerm[3]} \env} \to^* \go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack \aPolyFrame \aStack)} \not\to$}
    \step{label-5.3}{$\go {\scoped {(\ttyapp {\aTerm[3]} {\aType[1]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack \aPolyFrame \aStack)}}$}
  \end{proof}
  \step{label-6}{\case{\begin{pfenum}
                        \item $\aTerm = \ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]}$ (line~\ref{go:ite}) \label{pf:6-term}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[3]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[3]} {\env[1]}} \to^* \go {\scoped {\aTerm[3]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:6-ih1}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[4]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[4]} {\env[1]}} \to^* \go {\scoped {\aTerm[4]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:6-ih2}
                        \item $\forall \aStack[1], \forall \env[1].$ if $\scoped {\aTerm[5]} {\env[1]}$ is well scoped and $\aStack[1]$ is well scoped, then $\stackapp {\aStack[1]} {\subs {\aTerm[5]} {\env[1]}} \to^* \go {\scoped {\aTerm[5]} {\env[1]}} {\aStack[1]} \not\to$ \label{pf:6-ih3}
                      \end{pfenum}}}
  \begin{proof}
    \step{label-6.1}{$\stackapp \aStack {\subs {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} = \stackapp {(\nonEmptyStack {\aIteFrameAll \env {\aTerm[4]} {\aTerm[5]}} \aStack)} {\subs {\aTerm[3]} \env}$}
    \begin{proof}
      \pf\ By substitution~\ref{substitution} and stack evaluation~\ref{stack-evaluation}
    \end{proof}
    \step{label-6.2}{$\stackapp {(\nonEmptyStack {\aIteFrameAll \env {\aTerm[4]} {\aTerm[5]}} \aStack)} {\subs {\aTerm[3]} \env} \to^* \go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aIteFrameAll \env {\aTerm[4]} {\aTerm[5]}} \aStack)} \not\to$}
    \begin{proof}
      \step{label-6.2.1}{$\scoped {\aTerm[3]} \env$, $\scoped {\aTerm[4]} \env$ and $\scoped {\aTerm[5]} \env$ are well scoped}
      \begin{proof}
        \step{label-6.2.1.1}{$FV(\aTerm[3]) \subseteq FV(\aTerm)$, $FV(\aTerm[4]) \subseteq FV(\aTerm)$ and $FV(\aTerm[5]) \subseteq FV(\aTerm)$}
        \begin{proof}
          \pf\ By \stepref{label-6}:\ref{pf:4-term} and the definition of free variables
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By \toplevel:\ref{pf:term-scoped} and the definition of well scoped term~\ref{well-scoped-term}
        \end{proof}
      \end{proof}
      \step{label-6.2.2}{$(\nonEmptyStack {\aIteFrameAll \env {\aTerm[4]} {\aTerm[5]}} \aStack)$ is well scoped}
      \begin{proof}
        \pf\ By \toplevel:\ref{pf:stack-scoped} and the definition of well scoped stack~\ref{well-scoped-stack}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By \stepref{label-6}:\ref{pf:6-ih1}
      \end{proof}
    \end{proof}
    \step{label-6.3}{$\go {\scoped {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aIteFrameAll \env {\aTerm[4]} {\aTerm[5]}} \aStack)}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
  \end{proof}
  \step{label-7}{\case{\begin{pfenum}
                  \item $\aTerm = \tlet \aVar {\aTerm[3]} {\aTerm[4]}$ (line~\ref{go:let}) \label{pf:7-term}
                  \item $\forall \aStack', \forall \env'.$ if $\aStack'$ is well scoped and $\scoped {\aTerm[1]} {\env'}$ is well scoped, then $\stackapp {\aStack'} {\subs {\aTerm[3]} {\env'}} \to^* \go {\scoped {\aTerm[3]} {\env'}} {\aStack'} \not\to$ \label{pf:7-ih1}
                  \item $\forall \aStack', \forall \env'.$ if $\aStack'$ is well scoped and $\scoped {\aTerm[2]} {\env'}$ is well scoped, then $\stackapp {\aStack'} {\subs {\aTerm[4]} {\env'}} \to^* \go {\scoped {\aTerm[4]} {\env'}} {\aStack'} \not\to$ \label{pf:7-ih2}
                \end{pfenum}}}
  \begin{proof}
    \step{label-7.1}{$\stackapp \aStack {\subs {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env} \to^* \stackapp \aStack {(\tlet {\aVar[1]} {\aTerm[3]'} {\aTerm[4]'})}$ where $\subs {\aTerm[3]} \env \to^* {\aTerm[3]'}$ and $\subs {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}} \to^* {\aTerm[4]'}$}
    \step{label-7.2}{$\subs {\aTerm[3]} \env \to^* \go {\scoped {\aTerm[3]} \env} \emptyStack \not\to$}
    \step{label-7.3}{$\subs {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}} \to^* \go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack \not\to$}
    \step{label-7.4}{$\go {\scoped {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env} \aStack = \stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}$}
  \end{proof}
  \step{label-8}{\case{\begin{pfenum}
                  \item $\aTerm = \ttyann {\aTerm[3]} \aType$ (line~\ref{go:annot}) \label{pf:8-term}
                  \item $\forall \aStack', \forall \env'.$ if $\aStack'$ if well scoped and $\scoped {\aTerm[1]} {\env'}$ is well scoped, then $\stackapp {\aStack'} {\subs {\aTerm[3]} {\env'}} \to^* \go {\scoped {\aTerm[3]} {\env'}} {\aStack'} \not\to$ \label{pf:8-ih}
                \end{pfenum}}}
  \begin{proof}
    \step{label-8.1}{$\stackapp \aStack {\subs {\ttyann {\aTerm[3]} \aType} \env} \to \stackapp \aStack {\subs {\aTerm[3]} \env}$}
    \step{label-8.2}{$\stackapp \aStack {\subs {\aTerm[3]} \env} \to^* \go {\scoped {\aTerm[3]} \env} \aStack \not\to$}
    \step{label-8.3}{$\go {\scoped {\ttyann {\aTerm[3]} \aType} \env} \aStack = \go {\scoped {\aTerm[3]} \env} \aStack$}
  \end{proof}
\end{proof}

\begin{figure}
  \ocamlfrom{stack.ml}{go}
\end{figure}

\end{document}
