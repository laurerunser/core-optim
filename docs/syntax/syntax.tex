\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{pf}
\usepackage{plong}
\usepackage{listings-ocaml}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{geometry}
\newcommand{\TODO}[1]{\textcolor{red}{$\langle$ Pierre:}~#1\textcolor{red}{~$\rangle$}}

\begin{document}
\section{Syntax}
\subsection{Terms}
$
\begin{array}{ccll}
\aTerm, \aTerm[1], \aTerm[2] & ::= & & \\
& | & \aBase & \text{(base)} \\
& | & \tfun \aVar \aType \aTerm & \text{(abstraction)} \\
& | & \tapp \aTerm \aBase & \text{(function application)} \\
& | & \tlet \aVar \aTerm {\aTerm[1]} & \text{(let binding)} \\
& | & \ite \aTerm {\aTerm[1]} {\aTerm[2]} & \text{(conditionnal)}\\
& | & \ttyfun \aTypeVar \aTerm & \text{(type abstraction)} \\
& | & \ttyapp \aTerm \aType & \text{(type application)} \\
& | & \ttyann \aTerm \aType & \text{(type annotation)}
\end{array}
$\\
$
\begin{array}{ccll}
\aBase & ::= & & \\
& | & \aVar & \text{(variable)} \\
& | & \true & \text{(true)} \\
& | & \false & \text{(false)} \\
\end{array}
$
\subsection{Types}
$
\begin{array}{ccll}
\aType, \aType[1] & ::= & & \\
& | & \aTypeVar & \text{(type variable)} \\
& | & \tyBool & \text{(bool type)} \\
& | & \aDomType \to \aCodType & \text{(function type)} \\
& | & \tforall \aTypeVar \aType & \text{(polymorphic type)} \\
& | & \aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k} & \text{(tuples)}
\end{array}
$
\section{Free variables} \label{free-variable}
\subsection{Free type variables in type}
\begin{align*}
FV(\aTypeVar) &= \aTypeVar \\
FV(\tyBool) &= \emptyset \\
FV(\domToCod) &= FV(\aDomType) \cup FV(\aCodType) \\
FV(\tforall \aTypeVar \aType) &= FV(\aType) \setminus \{ \aTypeVar \} \\
FV(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k}) &= FV(\aType[2]) \cup FV(\aType[3]) \cup \ldots \cup FV(\aType_{k}) \\
\end{align*}
\subsection{Free variables in term}
\begin{align*}
FV(\aVar) &= \aVar \\
FV(\true) &= \emptyset \\
FV(\false) &= \emptyset \\
FV(\tfun \aVar \aType \aTerm) &= FV(\aType) \cup (FV(\aTerm) \setminus \{ \aVar \}) \\
FV(\tapp \aTerm \aBase) &= FV(\aTerm) \cup FV(\aBase) \\
FV(\tlet \aVar \aTerm {\aTerm[1]}) &= FV(\aTerm) \cup (FV(\aTerm[1]) \setminus \{\aVar\}) \\
FV(\ite \aTerm {\aTerm[1]} {\aTerm[2]}) &= FV(\aTerm) \cup FV(\aTerm[1]) \cup FV(\aTerm[2]) \\
FV(\ttyfun \aTypeVar \aTerm) &= FV(\aTerm) \setminus \{ \aTypeVar \} \\
FV(\ttyapp \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
FV(\ttyann \aTerm \aType) &= FV(\aTerm) \cup FV(\aType) \\
\end{align*}
\section{Scoped terms}
\subsection{Terms environnement}
$
\begin{array}{ccll}
\env & ::= & \\
& | & \envid & \text{(identity)}\\
& | & \envextend \rho \aVar \aBase & \text{(variable)} \\
& | & \envextend \rho \aTypeVar \aType & \text{(type variable)}
\end{array}
$\\
We will write $\scoped \aTerm \env$ to denote the pair of the term $\aTerm$ and its environment $\env$.  \\
Similarly, $\scoped \aType \env$ denotes the pair of the type $\aType$ and its environment $\env$. \\

\subsection{Substitution} \label{substitution}
\subsubsection{Type substitution}
\begin{align*}
\subs \aTypeVar \envid &= \aTypeVar \\
\subs \aTypeVar {\envextend \env \aVar \aBase} &= \subs \aTypeVar \rho \\
\subs \aTypeVar {\envextend \env {\aTypeVar[1]} \aType} &=
\begin{cases}
  \aType & \text{if } \aTypeVar = \aTypeVar[1] \\
  \subs \aTypeVar \env & \text{otherwise} \\
\end{cases} \\
\subs \tyBool \env &= \tyBool \\
\subs {(\aDomType \to \aCodType)} \env &= \subs \aDomType \env \to \subs \aCodType \env \\
\subs {(\tforall \aTypeVar \aType)} \env &= \tforall {\aTypeVar[1]} {\subs \aType {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\tforall \aTypeVar \aType) \cup FV(\env) \\
\subs {(\aType[2] \tprod \aType[3] \tprod \ldots \tprod \aType_{k})} \env &= \subs {\aType[2]} \env \tprod \subs {\aType[3]} \env \tprod \ldots \subs {\tprod \aType_{k}} \env
\end{align*}
\subsubsection{Term substitution}
\begin{align*}
\subs \aVar \envid &= \aVar \\
\subs \aVar {\envextend \env {\aVar[1]} \aBase} &=
\begin{cases}
  \aBase & \text{if } \aVar = \aVar[1] \\
  \subs \aVar \env & \text{otherwise}
\end{cases} \\
\subs \aVar {\envextend \env \aTypeVar \aType} &= \subs \aVar \env \\
\subs \true \env &= \true \\
\subs \false \env &= \false \\
\subs {(\tfun \aVar \aType \aTerm)} \env &= \tfun {\aVar[1]} {\subs \aType \env} {\subs \aTerm {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tfun \aVar \aType \aTerm) \cup FV(\env) \\
\subs {(\tapp \aTerm {\aTerm[1]})} \env &= \tapp {\subs \aTerm \env} {\subs {\aTerm[1]} \env} \\
\subs {(\tlet \aVar \aTerm \aTerm[1])} \env &= \tlet {\aVar[1]} {\subs \aTerm \env} {\subs {\aTerm[1]} {\envextend \env \aVar {\aVar[1]}}} \quad \aVar[1] \notin FV(\tlet \aVar \aTerm \aTerm[1]) \cup FV(\env) \\
\subs {(\ite \aTerm {\aTerm[1]} {\aTerm[2]})} \env &= \ite {\subs \aTerm \env} {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env} \\
\subs {(\ttyfun \aTypeVar \aTerm)} \env &= \ttyfun {\aTypeVar[1]} {\subs \aTerm {\envextend \env \aTypeVar {\aTypeVar[1]}}} \quad \aTypeVar[1] \notin FV(\ttyfun \aTypeVar \aTerm) \cup FV(\env) \\
\subs {(\ttyapp \aTerm \aType)} \env &= \ttyapp {\subs \aTerm \env} {\subs \aType \env} \\
\subs {\ttyann \aTerm \aType} \env &= \ttyann {\subs \aTerm \env} {\subs \aType \env}
\end{align*}

\subsection{Domaine}
The domaine of an environment is written $D(\env)$ and is equal to $\{ \aVar ~\vert~ \exists \aBase. \aVar \ne \aBase \text{ and } \subs \aVar \env = \aBase \} \cup \{ \aTypeVar ~\vert~ \exists \aType. \aTypeVar \ne \aType \text{ and } \subs \aTypeVar \env = \aType \}$

\subsection{Well scoped} \label{well-scoped-term}
$\scoped \aTerm \env$ is well-scoped if $FV(\aTerm) \subseteq D(\env)$ \\
$\scoped \aType \env$ is well-scoped if $FV(\aType) \subseteq D(\env)$

\section{Frames and stacks}
$
\begin{array}{ccll}
\aFrame & ::= & \\
& | & \aFunFrame & \text{(applied function)} \\
& | & \aPolyFrame & \text{(instantiated polymorphism)} \\
& | & \aIteFrame & \text{(if then else)}
\end{array}
$
\newline
\newline
$
\aStack ::= \emptyStack \:|\: \nonEmptyStack \aFrame \aStack \quad \text{(stacks)}
$
\subsection{Stack application} \label{stack-application}
\begin{align*}
  \stackapp \emptyStack \aTerm &= \aTerm \\
  \stackapp {(\nonEmptyStack \aFunFrame \aStack)} \aTerm &= \stackapp \aStack {\tapp \aTerm {(\subs \aBase \env)}} \\
  \stackapp {(\nonEmptyStack \aPolyFrame \aStack)} \aTerm &= \stackapp \aStack {\ttyapp \aTerm {\subs {\aType[1]} \env}} \\
  \stackapp {(\nonEmptyStack \aIteFrame \aStack)} \aTerm &= \stackapp \aStack {\ite \aTerm {\subs {\aTerm[1]} \env} {\subs {\aTerm[2]} \env}} \\
\end{align*}

\section{Typechecker}
\subsection{Type synthesis for terms} \label{term-typechecker}
The type synthesis judgment for terms is written
\fbox{$\judge \aContext \aTerm \aType$}
and reads "We infer the type $\aType$ for the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule  {\judgequal \aContext \aVar \aType}
        {\judge \aContext \aVar \aType}
        {Variable}

\aRule { }
       {\judge \aContext \true \tyBool}
       {True}

\aRule { }
       {\judge \aContext \false \tyBool}
       {False}

\aRule  {\judge {\ctxtExtend \aContext \aVar {\aType[1]}} \aTerm \aType}
        {\judge \aContext {\tfun \aVar {\aType[1]} \aTerm} \domToCod}
        {Abstraction}

\aRule   {\judge \aContext \aTerm \domToCod \\
          \judgecheck \aContext {\aType[1]} {\aTerm[1]}}
         {\judge \aContext {\tapp \aTerm {\aTerm[1]}} \aType}
         {Function application}

\aRule   {\judge \aContext \aTerm \aType \\
          \judge {\ctxtExtend \aContext \aVar \aType} {\aTerm[1]} {\aType[1]}}
         {\judge \aContext {\tlet \aVar \aTerm {\aTerm[1]}} {\aType[1]}}
         {Let binding}

\aRule   {\judge \aContext \aTerm \tyBool \\
          \judge \aContext {\aTerm[2]} \aType \\
          \judge \aContext {\aTerm[3]} \aType}
         {\judge \aContext {\ite \aTerm {\aTerm[2]} {\aTerm[3]}} \aType}
         {If then else}

\aRule   {\judge {\aContext \ctxtSep \aTypeVar} \aTerm \aType \\
          \aTypeVar \notin FV(\aContext)}
         {\judge \aContext {\ttyfun \aTypeVar \aTerm} {\tforall \aTypeVar \aType}}
         {Type abstraction}

\aRule  {\judge \aContext \aTerm {\tforall \aTypeVar \aType}}
        {\judge \aContext {\ttyapp \aTerm {\aType[1]}} {\subs \aType {\envextend \envid \aTypeVar {\aType[1]}}}}
        {Type application}

\aRule  {\judgecheck \aContext \aType \aTerm}
        {\judge \aContext {\ttyann \aTerm \aType} \aType}
        {Type annotation}
\end{mathpar}

\subsection{Type checking for terms}
The type checking judgment for terms is written
\fbox{$\judgecheck \aContext \aType \aTerm$}
and reads "We verify the type $\aType$ of the term $\aTerm$ in the context $\aContext$".
\begin{mathpar}
\aRule   {\judge \aContext \aTerm {\aType[1]} \\
          \judgequiv \aContext {\aType[1]} \aType}
         {\judgecheck \aContext \aType \aTerm}
         {Type checking}

\end{mathpar}
\subsection{Type synthesis for stacks} \label{stack-typechecker}
The type synthesis judgment for stacks is written
\fbox{$\frameJudge \aContext \aStack {\aType[1]} \aType$}
and reads "In the context $\aContext$, the stack $\aStack$ plugged with a term of type $\aType[1]$ has type $\aType$".
\begin{mathpar}
\aRule   { }
         {\frameJudge \aContext {\scoped \emptyStack \env} \aType {\aType}}
         {Empty stack}

\aRule   {\frameJudge \aContext \aStack \aType {\aType[2]} \\
          \judgecheck \aContext {\aType[1]} \aBase}
         {\frameJudge \aContext {(\nonEmptyStack \aFunFrame \aStack)} \domToCod {\aType[2]}}
         {Applied function frame}

\aRule   {\frameJudge \aContext \aStack {\subs \aType {\envextend \envid \aTypeVar {\aType[1]}}} {\aType[2]}}
         {\frameJudge \aContext {(\nonEmptyStack \aPolyFrame \aStack)} {\tforall \aTypeVar \aType} {\aType[2]}}
         {Instantiated polymorphism frame}

\aRule  {\judge \aContext {\aTerm[1]} {\aType[2]} \\
          \judge \aContext {\aTerm[2]} {\aType[2]} \\
          \frameJudge \aContext \aStack {\aType[2]} {\aType}}
        {\frameJudge \aContext {(\nonEmptyStack \aIteFrame \aStack)} \tyBool \aType}
        {IfThenElse frame}

\end{mathpar}

\section{Simplifications}
\subsection{Constant folding} \label{constant-folding}
\subsubsection{Rules}
\begin{mathpar}
\aRule   { }
         {\simplBeta {\tapp {(\tfun \aVar \aType \aTerm)} \aBase} {{\subs \aTerm {\envextend \envid \aVar \textcolor{orange}{\frak{\aBase}}}}}}
         {}

\aRule   { }
         {\simplBeta {\ttyapp {(\ttyfun \aTypeVar \aTerm)} \aType} {{\subs \aTerm {\envextend \envid \aTypeVar \textcolor{orange}{\frak{\aType}}}}}}
         {}

\aRule   { }
         {\simplBeta {{\ite \true \aTerm {\aTerm[1]}}} {\aTerm}}
         {}

\aRule   { }
         {\simplBeta {{\ite \false \aTerm {\aTerm[1]}}} {\aTerm[1]}}
         {}
\end{mathpar}
\subsubsection{Congruence rules}
\begin{mathpar}
\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aVar {\textcolor{orange}{\frak{\aVar}}}}} {\aTerm[1]}}
         {\simplBeta {\tfun \aVar \aType \aTerm} {\tfun {\textcolor{orange}{\frak{\aVar}}} \aType {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\tapp \aTerm \aBase} \tapp {\aTerm[1]} \aBase}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'}}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet \aVar {\aTerm'}} {\aTerm[1]}}
         {}

\aRule   {\simplBeta {\subs {\aTerm[1]} {\envextend \envid \aVar {\textcolor{orange}{\frak{\aVar}}}}} {\aTerm[1]'}}
         {\simplBeta {\tlet \aVar \aTerm {\aTerm[1]}} {\tlet {\textcolor{orange}{\frak{\aVar}}} \aTerm \aTerm[1]'}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite {\aTerm'} {\aTerm[1]} {\aTerm[2]}}}
         {}

\aRule   {\simplBeta {\aTerm[1]} {\aTerm[1]'}}
          {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]'} {\aTerm[2]} }}
{}

\aRule   {\simplBeta {\aTerm[2]} {\aTerm[2]'}}
         {\simplBeta {\ite \aTerm {\aTerm[1]} {\aTerm[2]}} {\ite \aTerm {\aTerm[1]} {\aTerm[2]'}}}
         {}

\aRule   {\simplBeta {\subs \aTerm {\envextend \envid \aTypeVar {\textcolor{orange}{\frak{\aTypeVar}}}}} {\aTerm[1]}}
         {\simplBeta {\ttyfun \aTypeVar \aTerm} {\ttyfun {\textcolor{orange}{\frak{\aTypeVar}}} {\aTerm[1]}}}
         {}

\aRule   {\simplBeta \aTerm {\aTerm[1]}}
         {\simplBeta {\ttyapp \aTerm \aType} {\ttyapp {\aTerm[1]} \aType}}
         {}

\aRule   { }
         {\simplBeta {\ttyann \aTerm \aType} \aTerm}
         {}

\end{mathpar}
\subsection{Correctness}
\begin{proof}
  \pflet
  {\begin{enumerate}
    \item $\aContext$ be a context
    \item $\aTerm$ be a term
    \item $\aStack$ be a stack
  \end{enumerate}}
  \assume{$\exists \aType,\aType[1]$ such that
    \begin{enumerate}
      \item $\judge \aContext {\subs \aTerm \env} \aType$ \label{pf:term-typed}
      \item $\aStack$ is fully simplifiable \label{pf:stack-simpl}
      \item $\frameJudge \aContext \aStack \aType {\aType[1]}$ \label{pf:stack-typed}
    \end{enumerate}
    }
  \prove{$\simplBeta[*] {\stackapp \aStack {\subs \aTerm \env}} {\betaNormal {\go {\scoped \aTerm \env} \aStack}}$ and $\judge \aContext {\go {\scoped \aTerm \env} \aStack} {\aType[1]}$}
  \pfsketch\ Proof by lexicographic induction on $(\aStack, \aTerm)$.
  \step{label-1}{\case{$\aTerm = \aBase$ (line~\ref{go:base})}}
  \begin{proof}
    \step{label-1.1}{\case{$\subs \aBase \env = \true$ and $\aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'}$}}
    \begin{proof}
      \step{label-1.1.1}{$\go {\scoped \aBase \env} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} = \go {\scoped {\aTerm[1]} {\env'} {\aStack'}}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} {\betaNormal {\go {\scoped {\aTerm[1]} {\env'} {\aStack'}}}}$ and $\judge \aContext {\go {\scoped {\aTerm[1]} {\env'} {\aStack'}}} {\aType[1]}$}
      \begin{proof}
        \step{label-1.1.2.1}{$\exists \aType[2].\judge \aContext {\subs {\aTerm[1]} {\env'}} {\aType[2]}$ and $\frameJudge \aContext {\aStack'} {\aType[2]} {\aType[1]}$}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-typed}
        \end{proof}
        \step{label-1.1.2.2}{$\aStack'$ is fully simplifiable}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By definition of fully simplifiable
        \end{proof}
      \end{proof}
      \step{label-1.1.3}{$\simplBeta {\stackapp {(\nonEmptyStack {\aIteFrame [\env']} {\aStack'})} \true} {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}}$}
      \begin{proof}
        \pf\ By stack application \ref{stack-application} and $\rightsquigarrow$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\
        \begin{enumerate}
          \item $\judge \aContext {\go {\scoped \aBase \env} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})}} {\aType[1]}$ by \stepref{label-1.1.1} and \stepref{label-1.1.2}
          \item We get the following equations:\\
            $\begin{aligned}
            \stackapp \aStack {\subs \aBase {\env}} &= \stackapp {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} \true && \text{by case analysis \stepref{label-1} and \stepref{label-1.1}}
            \\ &\rightsquigarrow {\stackapp {\aStack'} {\subs {\aTerm[1]} {\env'}}} && \text{by \stepref{label-1.1.3}}
            \\ &\rightsquigarrow^{*} {\go {\scoped {\aTerm[1]} {\env'}} {\aStack'}} && \text{by \stepref{label-1.1.2}}
            \\ &= {\go {\scoped {\aBase} {\env}} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})}} && \text{by \stepref{label-1.1.1}}
            \\ &\not \rightsquigarrow && \text{by \stepref{label-1.1.2}}
            \end{aligned}$
        \end{enumerate}
      \end{proof}
    \end{proof}
    \step{label-1.2}{\case{$\subs \aBase \env = \false$ and $\aStack = \nonEmptyStack {\aIteFrame[\env']} {\aStack'}$}}
    \begin{proof}
      \step{label-1.2.1}{$\go {\scoped \aBase \env} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} = \go {\scoped {\aTerm[2]} {\env'} {\aStack'}}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.2.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[2]} {\env'}}} {\betaNormal {\go {\scoped {\aTerm[2]} {\env'} {\aStack'}}}}$ and $\judge \aContext {\go {\scoped {\aTerm[2]} {\env'} {\aStack'}}} {\aType[1]}$}
      \begin{proof}
        \step{label-1.2.2.1}{$\exists \aType[2].\judge \aContext {\subs {\aTerm[2]} {\env'}} {\aType[2]}$ and $\frameJudge \aContext {\aStack'} {\aType[2]} {\aType[1]}$}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-typed}
        \end{proof}
        \step{label-1.2.2.2}{$\aStack'$ is fully simplifiable}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By definition of fully simplifiable
        \end{proof}
      \end{proof}
      \step{label-1.2.3}{$\simplBeta {\stackapp {(\nonEmptyStack \aIteFrame {\aStack'})} \false} {\stackapp {\aStack'} {\subs {\aTerm[2]} {\env'}}}$}
      \begin{proof}
        \pf\ By stack application \ref{stack-application} and $\rightsquigarrow$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\
        \begin{enumerate}
          \item $\judge \aContext {\go {\scoped \aBase \env} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})}} {\aType[1]}$ by \stepref{label-1.2.1} and \stepref{label-1.2.2}
          \item We get the following equations: \\
            $\begin{aligned}
            \stackapp \aStack {\subs \aBase {\env}} &= \stackapp {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})} \false && \text{by case analysis \stepref{label-1} and \stepref{label-1.2}}
            \\ &\rightsquigarrow {\stackapp {\aStack'} {\subs {\aTerm[2]} {\env'}}} && \text{by \stepref{label-1.2.3}}
            \\ &\rightsquigarrow^{*} {\go {\scoped {\aTerm[2]} {\env'}} {\aStack'}} && \text{by \stepref{label-1.2.2}}
            \\ &= {\go {\scoped {\aBase} {\env}} {(\nonEmptyStack {\aIteFrame[\env']} {\aStack'})}} && \text{by \stepref{label-1.2.1}}
            \\ &\not \rightsquigarrow && \text{by \stepref{label-1.2.2}}
            \end{aligned}$
        \end{enumerate}
      \end{proof}
    \end{proof}
    \step{label-1.3}{\case{Else}}
    \begin{proof}
      \step{label-1.3.1}{$\go {\scoped \aBase \env} \aStack = \stackapp \aStack {\subs \aBase \env}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-1.3.2}{$\betaNormal {\stackapp \aStack {\subs \aBase \env}}$}
      \begin{proof}
        \pf\ By stack application and $\rightsquigarrow$
      \end{proof}
      \step{label-1.3.3}{$\judge \aContext {\stackapp \aStack {\subs \aBase \env}} {\aType[1]}$}
      \begin{proof}
        \pf\ By \ref{pf:term-typed} and \ref{pf:stack-typed}
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-2}{\case{$\aTerm = (\tfun \aVar {\aType[2]} {\aTerm[3]})$}}
  \begin{proof}
    \step{label-2.1}{\case{$\aStack = \nonEmptyStack \aFunFrame {\aStack'}$ (line~\ref{go:fun-holefun})}}
    \begin{proof}
      \step{label-2.1.1}{$\go {\scoped {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aStack'}$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aStack'}}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aStack'}} {\aType[1]}$}
      \begin{proof}
        \step{label-2.1.2.1}{$\exists \aType[3]. \judge \aContext {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aType[3]}$ and $\frameJudge \aContext {\aStack'} {\aType[3]} {\aType[1]}$}
        \begin{proof}
          \step{label-2.1.2.1.1}{$\exists \aType[3]. \judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \aType[3]$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
          \begin{proof}
            \pf\ By substitution and inversion of \ref{pf:term-typed}
          \end{proof}
          \step{label-2.1.2.1.2}{$\judge \aContext \aBase {\subs {\aType[2]} \env}$ and $\frameJudge \aContext {\aStack'} {\aType[3]} {\aType[1]}$}
          \begin{proof}
            \pf\ By inversion of \ref{pf:stack-typed}
          \end{proof}
        \end{proof}
        \step{label-2.1.2.2}{$\aStack'$ is fully simplifiable}
        \begin{proof}
          \pf\ By inversion of \ref{pf:stack-simpl}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH
        \end{proof}
      \end{proof}
      \step{label-2.1.3}{$\simplBeta {\stackapp {(\nonEmptyStack \aFunFrame {\aStack'})} {\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env}}{\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}}}$}
      \begin{proof}
        \pf\ \\
        $\begin{aligned}
          & \stackapp {(\nonEmptyStack \aFunFrame {\aStack'})} {\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \\
          & = \stackapp {\aStack'} {\tapp {(\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env)} \aBase} && \text{by stack application \ref{stack-application}}\\
          & = \stackapp {\aStack'} {\tapp {(\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}})} \aBase } \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env) && \text{by substitution \ref{substitution}}\\
          & \rightsquigarrow \stackapp {\aStack'} {\subs {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\envextend \envid {\aVar[1]} \aBase}} && \text{by $\rightsquigarrow$ \ref{constant-folding}} \\
          & = \stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}} && \text{as $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
        \end{aligned}$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ \begin{enumerate}
          \item $\judge \aContext {\go {\scoped {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \aStack} {\aType[1]}$ by \stepref{label-2.1.1} and \stepref{label-2.1.2}
          \item We get the following equations: \\
          $\begin{aligned}
            \stackapp \aStack {\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env}
            &= \stackapp {(\nonEmptyStack \aFunFrame {\aStack'})} {\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} && \text{by case analysis \stepref{label-2} and \stepref{label-2.1}} \\
            &\rightsquigarrow \stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aVar \aBase}} && \text{by \stepref{label-2.1.3}} \\
            &\rightsquigarrow^* \go {\scoped {\aTerm[3]} {\envextend \env \aVar \aBase}} {\aStack'} && \text{by \stepref{label-2.1.2}} \\
            &= \go {\scoped {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \aStack && \text{by \stepref{label-2.1.1}} \\
            &\not \rightsquigarrow && \text{by \stepref{label-2.1.2}}
          \end{aligned}$
        \end{enumerate}
      \end{proof}
    \end{proof}
    \step{label-2.2}{\case{Else (line~\ref{go:fun-else})}}
    \begin{proof}
      \step{label-2.2.1}{$\go {\scoped {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \begin{proof}
        \pf\ By definition of \textsf{go}
      \end{proof}
      \step{label-2.2.2}{$\exists \aType[3]. \simplBeta[*] {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}$ and $\judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack} {\aType[3]}$}
      \begin{proof}
        \step{label-2.2.2.1}{$\exists \aType[3]. \judge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} {\subs {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} {\aType[3]} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
        \begin{proof}
          \pf\ By substitution and inversion of \ref{pf:term-typed}
        \end{proof}
        \step{label-2.2.2.2}{$\emptyStack$ is fully simplifiable}
        \begin{proof}
          \pf\ By definition of fully simplifiable
        \end{proof}
        \step{label-2.2.2.3}{$\frameJudge {\ctxtExtend \aContext {\aVar[1]} {\subs {\aType[2]} \env}} \emptyStack {\aType[3]} {\aType[3]}$}
        \begin{proof}
          \pf\ By empty stack rule \ref{stack-typechecker}
        \end{proof}
        \qedstep
        \begin{proof}
          \pf\ By IH
        \end{proof}
      \end{proof}
      \step{label-2.2.3}{$\betaNormal{\stackapp \aStack {\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}}$}
      \begin{proof}
        \pf\ By \stepref{label-2.2.2} and $\rightsquigarrow$
      \end{proof}
      \step{label-2.2.4}{$\judge \aContext {\stackapp \aStack {\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}} {\aType[1]}$}
      \begin{proof}
        \pf\ By substitution, \stepref{label-2.2.2}, inversion of \ref{pf:term-typed} and \ref{pf:stack-typed}
      \end{proof}
      \step{label-2.2.5}{$\simplBeta[*] {\stackapp \aStack {\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env}} {\stackapp \aStack {\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}}$}
      \begin{proof}
        \pf\ By substitution and $\rightsquigarrow^*$
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ \begin{enumerate}
          \item $\judge \aContext {\go {\scoped {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \aStack} {\aType[1]}$ by \stepref{label-2.2.1} and \stepref{label-2.2.4}
          \item We get the following equations: \\
          $\begin{aligned}
            \stackapp \aStack {\subs {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env}
            &\rightsquigarrow^* {\stackapp \aStack {\tfun {\aVar[1]} {\subs {\aType[2]} \env} {\go {\scoped {\aTerm[3]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}} \text{ with } \aVar[1] \notin FV(\aTerm) \cup FV(\env) && \text{by \stepref{label-2.2.5}} \\
            &= \go {\scoped {(\tfun \aVar {\aType[2]} {\aTerm[3]})} \env} \aStack && \text{by \stepref{label-2.2.1}} \\
            &\not \rightsquigarrow && \text{by \stepref{label-2.2.3}}
          \end{aligned}$
        \end{enumerate}
      \end{proof}
    \end{proof}
  \end{proof}
  \step{label-3}{\case{$\aTerm = \ttyfun \aTypeVar {\aTerm[3]}$}}
  \begin{proof}
    \step{label-3.1}{\case{$\aStack = \nonEmptyStack \aPolyFrame {\aStack'}$ (line~\ref{go:tyfun-holetype})}}
    \begin{proof}
      \step{label-3.1.1}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}} {\aStack'}$}
      \step{label-3.1.2}{$\simplBeta[*] {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}} {\aStack'}}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}} {\aStack'}} {\aType[1]}$}
      \step{label-3.1.3}{$\simplBeta{\stackapp {(\nonEmptyStack \aPolyFrame {\aStack'})} {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env}} {\stackapp {\aStack'} {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aType[1]}}}}$}
    \end{proof}
    \step{label-3.2}{\case{Else (line~\ref{go:tyfun-else})}}
    \begin{proof}
      \step{label-3.2.1}{$\go {\scoped {(\ttyfun \aTypeVar {\aTerm[3]})} \env} \aStack = \stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$ with $\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
      \step{label-3.2.2}{$\simplBeta[*] {\subs {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} {\betaNormal {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}$ and $\judge {\aContext \ctxtSep \aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}} \emptyStack}} {\aType[3]}$}
      \step{label-3.2.3}{$\betaNormal{\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}}$}
      \step{label-3.2.4}{$\judge \aContext {\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}} {\aType[1]}$}
      \step{label-3.2.5}{$\simplBeta[*] {\stackapp \aStack {\subs {(\ttyfun \aTypeVar {\aTerm[3]})} \env}} {\stackapp \aStack {\ttyfun {\aTypeVar[1]} {\go {\scoped {\aTerm[3]} {\envextend \env \aTypeVar {\aTypeVar[1]}}} \emptyStack}}}$}
    \end{proof}
  \end{proof}
  \step{label-4}{\case{$\aTerm = \tapp {\aTerm[3]} {\aBase}$ (line~\ref{go:funApply})}}
  \begin{proof}
    \step{label-4.1}{$\go {\scoped {(\tapp {\aTerm[3]} \aBase)} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-4.2}{$\simplBeta[*] {\stackapp {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} {\subs {\aTerm[3]} \env}} \betaNormal{{\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)}}}$ and $ \judge \aContext {\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)}} {\aType[1]}$}
    \begin{proof}
      \step{label-4.2.1}{$\exists \aType[2]. \judge \aContext {\subs {\aTerm[3]} \env} {\aType[2] \to \aType}$}
      \begin{proof}
        \pf\ By substitution and inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-4.2.2}{$(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)$ is fully simplifiable}
      \begin{proof}
        \pf\ By \ref{pf:stack-simpl}
      \end{proof}
      \step{label-4.2.3}{$\frameJudge \aContext {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} {\aType[2] \to \aType} {\aType[1]}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-typed}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH
      \end{proof}
    \end{proof}
    \step{label-4.3}{$\stackapp \aStack {\subs {(\tapp {\aTerm[3]} {\aBase})} \env} = \stackapp {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} {\subs {\aTerm[3]} \env}$}
    \begin{proof}
      \pf\ By substitution and stack application
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ \begin{enumerate}
        \item $\judge \aContext {\go {\scoped {(\tapp {\aTerm[3]} \aBase)} \env} \aStack} {\aType[1]}$ by \stepref{label-4.1} and \stepref{label-4.2}
        \item We get the following equations:\\
        $\begin{aligned}
          \stackapp \aStack {\subs {(\tapp {\aTerm[3]} {\aBase})} \env}
          &= \stackapp {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} {\subs {\aTerm[3]} \env} && \text{by \stepref{label-4.3}} \\
          &\rightsquigarrow^* \go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aFunFrame[\subs \aBase \env]} \aStack)} && \text{by \stepref{label-4.2}} \\
          &= \go {\scoped {(\tapp {\aTerm[3]} \aBase)} \env} \aStack && \text{by \stepref{label-4.1}} \\
          &\not \rightsquigarrow && \text{by \stepref{label-4.2}}
        \end{aligned}$
      \end{enumerate}
    \end{proof}
  \end{proof}
  \step{label-5}{\case{$\aTerm = \ttyapp {\aTerm[3]} {\aType[1]}$ (line~\ref{go:typeApply})}}
  \begin{proof}
    \step{label-5.1}{$\go {\scoped {(\ttyapp {\aTerm[3]} {\aType[1]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)}}$}
    \step{label-5.2}{$\simplBeta[*] {\stackapp {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)}}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)}} {\aType[1]}$}
    \step{label-5.3}{$\stackapp \aStack {\subs {(\ttyapp {\aTerm[3]} {\aType[1]})} \env} = \stackapp {(\nonEmptyStack {\aPolyFrame[\subs {\aType[1]} \env]} \aStack)} {\subs {\aTerm[3]} \env}$}
  \end{proof}
  \step{label-6}{\case{$\aTerm = \ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]}$ (line~\ref{go:ite})}}
  \begin{proof}
    \step{label-6.1}{$\go {\scoped {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aStack = \go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)}}$}
    \begin{proof}
      \pf\ By definition of \textsf{go}
    \end{proof}
    \step{label-6.2}{$\simplBeta[*]{\subs {\aTerm[4]} \env} {\betaNormal{\go {\scoped {\aTerm[4]} \env} \emptyStack}}$ and $\judge \aContext {\go {\scoped {\aTerm[4]} \env} \emptyStack} {\aType}$} 
    \begin{proof}
      \step{label-6.2.1}{$\judge \aContext {\subs {\aTerm[4]} \env} {\aType}$}
      \begin{proof}
        \pf\ By substitution and inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-6.2.2}{$\emptyStack$ is fully simplifiable}
      \begin{proof}
        \pf\ By definition of fully simplifiable
      \end{proof}
      \step{label-6.2.3}{$\frameJudge \aContext \emptyStack \aType \aType$}
      \begin{proof}
        \pf\ By empty stack rule \ref{stack-typechecker}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH
      \end{proof}
    \end{proof}
    \step{label-6.3}{$\simplBeta[*]{\subs {\aTerm[5]} \env} {\betaNormal{\go {\scoped {\aTerm[5]} \env} \emptyStack}}$ and $\judge \aContext {\go {\scoped {\aTerm[5]} \env} \emptyStack} {\aType}$}
    \step{label-6.4}{$\simplBeta[*]{\stackapp {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)} {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)}}}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)}}} {\aType[1]}$}
    \begin{proof}
      \step{label-6.4.1}{$\judge \aContext {\subs {\aTerm[3]} \env} \tyBool$}
      \begin{proof}
        \pf\ By substitution and inversion of \ref{pf:term-typed}
      \end{proof}
      \step{label-6.4.2}{$(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)$ is fully simplifiable}
      \begin{proof}
        \pf\ TODO
      \end{proof}
      \step{label-6.4.3}{$\frameJudge \aContext {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)} \tyBool {\aType[1]}$}
      \begin{proof}
        \pf\ By inversion of \ref{pf:stack-typed}, \stepref{label-6.2} and \stepref{label-6.3}
      \end{proof}
      \qedstep
      \begin{proof}
        \pf\ By IH
      \end{proof}
    \end{proof}
    \step{label-6.5}{$\simplBeta[*]{\stackapp \aStack {\subs {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env}} {\stackapp {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)} {\subs {\aTerm[3]} \env}}$}
    \begin{proof}
      \pf\ By substitution, $\rightsquigarrow^*$ and stack evaluation
    \end{proof}
    \qedstep
    \begin{proof}
      \pf\ \begin{enumerate}
        \item $\judge \aContext {\go {\scoped {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aStack} {\aType[1]}$ by \stepref{label-6.1} and \stepref{label-6.4}
        \item We get the following equations: \\
        $\begin{aligned}
          \stackapp \aStack {\subs {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env}
          &\rightsquigarrow^* \stackapp {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)} {\subs {\aTerm[3]} \env} && \text{by \stepref{label-6.5}} \\
          &\rightsquigarrow^* \go {\scoped {\aTerm[3]} \env} {(\nonEmptyStack {\aIteFrameAll {(\go {\scoped {\aTerm[4]} \env} \emptyStack)} {(\go {\scoped {\aTerm[5]} \env} \emptyStack)} \env} \aStack)} && \text{by \stepref{label-6.4}} \\
          &= \go {\scoped {(\ite {\aTerm[3]} {\aTerm[4]} {\aTerm[5]})} \env} \aStack && \text{by \stepref{label-6.1}} \\
          &\not \rightsquigarrow && \text{by \stepref{label-6.4}}
        \end{aligned}$
      \end{enumerate}
    \end{proof}
  \end{proof}
  \step{label-7}{\case{$\aTerm = \tlet \aVar {\aTerm[3]} {\aTerm[4]}$ (line~\ref{go:let})}}
  \begin{proof}
    \step{label-7.1}{$\go {\scoped {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env} \aStack = \stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})} \text{ with }\aVar[1] \notin FV(\aTerm) \cup FV(\env)$}
    \step{label-7.2}{$\simplBeta[*] {\subs {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} {\betaNormal{\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack}}$ and $\judge {\ctxtExtend \aContext {\aVar[1]} {\aType[2]}} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack} \aType$}
    \step{label-7.3}{$\simplBeta[*] {\subs {\aTerm[3]} \env } {\betaNormal{\go {\scoped {\aTerm[3]} \env} \emptyStack}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\aType[2]}$}
    \step{label-7.4}{$\betaNormal{\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}}$}
    \step{label-7.5}{$\judge \aContext {\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}} {\aType[1]}$}
    \step{label-7.6}{$\simplBeta[*] {\stackapp \aStack {\subs {(\tlet \aVar {\aTerm[3]} {\aTerm[4]})} \env}} {\stackapp \aStack {(\tlet {\aVar[1]} {\go {\scoped {\aTerm[3]} \env} \emptyStack} {\go {\scoped {\aTerm[4]} {\envextend \env \aVar {\aVar[1]}}} \emptyStack})}}$}
  \end{proof}
  \step{label-8}{\case{$\aTerm = \ttyann {\aTerm[3]} {\aType[2]}$ (line~\ref{go:annot})}}
  \begin{proof}
    \step{label-8.1}{$\go {\scoped {\ttyann {\aTerm[3]} {\aType[2]}} \env} \aStack = \go {\scoped {\aTerm[3]} \env} \aStack$}
    \step{label-8.2}{$\simplBeta[*] {\stackapp \aStack {\subs {\aTerm[3]} \env}} {\betaNormal{\go {\scoped {\aTerm[3]} \env} \aStack}}$ and $\judge \aContext {\go {\scoped {\aTerm[3]} \env} \aStack} {\aType[1]}$}
    \step{label-8.3}{$\simplBeta{\stackapp \aStack {\subs {\ttyann {\aTerm[3]} {\aType[2]}} \env}} {\stackapp \aStack {\subs {\aTerm[3]} \env}}$}
  \end{proof}
\end{proof}

\newgeometry{top=0.5cm}
\begin{figure}
  \ocamlfrom{stack.ml}{go}
\end{figure}
\restoregeometry

\subsection{Some problems with typing stacks}

We ran into problems while trying to typecheck stacks.

Here is one example: 
$$
\tapp {(\ttyapp {(\ttyfun \aTypeVar {(\tfun \aVar \aTypeVar
        {(\tapp {(\tapp {(\ttyapp { \square } {\aTypeVar[1]})} \aVar)} {\aVar[1]})})})}
        \tyBool)} \true
$$

After 2 rounds of simplification, we end up with the following stack, with $\env = \envextend {\envextend \envid \aTypeVar \tyBool} \aVar \true$.

\begin{mathpar}
\aRule
            {\aRule
              {\aRule
              { {\frameJudge
                 {\aContext}
                 {\emptyStack}
                 {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}
                 {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}  \\
                {\judge {\aContext} {\aVar[1]} {\aTypeVar[1]}}
              }
              {{\frameJudge 
                {\aContext}
                {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}
                {{\aTypeVar[1]} \to {\aType[2][{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
                {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}} \\
                {\judge {\aContext} {\aVar} {\aTypeVar}}
                }
              {}}
              {\frameJudge
              {\aContext}
              {\nonEmptyStack {\aFunFrameAll {\aVar} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}}
              {\aTypeVar \to {\aTypeVar[1]} \to {\aType[2][{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
              {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
              {}
            }
            {\frameJudge
              {\aContext = \hasType \aVar \aTypeVar, \hasType {\aVar[1]} {\aTypeVar[1]}}
              {\nonEmptyStack {\aPolyFrameAll {\aTypeVar[1]} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar} \rho} {\nonEmptyStack {\aFunFrameAll {\aVar[1]} \rho} \emptyStack}}}
              {\forall {\aTypeVar[2]}, {\aTypeVar \to {\aTypeVar[2]} \to {\aType[2]}}}
              {\aType[2] [{\aTypeVar[2]} \mapsto {\aTypeVar[1]}]}}
            {}
\end{mathpar}
In the example above, if you keep $\aTypeVar \mapsto \tyBool$, but change $\aVar \mapsto 42$, the
resulting type is the same, but the stack shouldn't typecheck.
The problem is that we are not using substitutions while typechecking our stacks.

So we changed the rules to include the substitutions on the terms before checking them, and on the environement.

With those rules, we can accuratly typecheck the following example: \\
$$\ttyapp {(\ttyfun \aTypeVar {\ttyapp {(\ttyapp {(\ttyfun {\aTypeVar[1]} {\ttyapp {\square} {\aTypeVar[1]}})} \tyBool)} \aTypeVar})} {\mathbb{N}}$$

\begin{mathpar}
\aRule
  {\aRule
    {\frameJudge
      {\subs {\subs {\aContext} {\env[2]}} {\env[3]}}
      {\emptyStack}
      {{\subs {\aTypeVar} {\env[3]}} \times {\subs {\aTypeVar[1]} {\env[2]}}}
      {\mathbb{N} \times \tyBool}}
    {\frameJudge
      {\subs {\aContext} {{\env[2]}}}
      {\square \: \scoped {\aTypeVar} {{\env[3]} = \aTypeVar \mapsto \mathbb{N}} : \emptyStack}
      {\forall {\aType[3]} {{{\aType[3]} \times {\subs {\aTypeVar[1]} {\env[2]}}}}}
      {\mathbb{N} \times \tyBool}}
    {}}
  {\frameJudge
    {\aContext = \aTypeVar, {\aTypeVar[1]}}
    {{\square \: \scoped {\aTypeVar[1]} {{\env[2]} = \envid, \aTypeVar \mapsto \mathbb{N}, {\aTypeVar[1]} \mapsto \tyBool}} : {\square \: \scoped {\aTypeVar} {{\env[3]} = \aTypeVar \mapsto \mathbb{N}}} : \emptyStack}
    {\forall {\aType[2]} {\forall {\aType[3]} {{{\aType[3]} \times {\aType[2]}}}}}
    {\mathbb{N} \times \tyBool}}
  {}
\end{mathpar}
\end{document}